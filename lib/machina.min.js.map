{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","machina.js","webpack:/webpack/bootstrap acca941d5a487012791a","webpack:///src/machina.js","webpack:/external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///src/emitter.js","webpack:///src/utils.js","webpack:///src/events.js","webpack:///src/Fsm.js","webpack:///src/BehavioralFsm.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_","emitter","merge","instance","Fsm","BehavioralFsm","utils","eventListeners","newFsm","getInstance","emit","eventName","args","getLeaklessArgs","arguments","each","callback","useSafeEmit","apply","exception","console","log","stack","slice","on","self","*","push","off","without","getDefaultBehavioralOptions","initialState","states","namespace","makeFsmNamespace","hierarchy","pendingDelegations","getDefaultClientMeta","inputQueue","targetReplayState","state","undefined","priorState","priorAction","currentAction","currentActionArgs","inExitHandler","startIdx","result","i","length","getChildFsmInstance","config","childFsmDefinition","listenToChild","fsm","child","data","events","NO_HANDLER","ticket","delegated","bubbling","inputType","handle","HANDLING","createUUID","s","hexDigits","substr","Math","floor","random","join","machinaCount","_machKeys","extend","protoProps","staticProps","parent","machObj","Ctor","hasOwnProperty","constructor","blendedState","instanceStates","cloneDeep","prototype","transform","accum","val","key","indexOf","__super__","getDefaultOptions","NEXT_TRANSITION","HANDLED","TRANSITION","TRANSITIONED","INVALID_STATE","DEFERRED","NEW_FSM","ensureClientMeta","initClient","Error","transition","_stamped","defaults","ensureClientArg","_args","unshift","splice","getHandlerArgs","isCatchAll","input","getSystemHandlerArgs","client","buildEventPayload","isPlainObject","methodWithClientInjected","options","initialize","topLevelEmitter","MACHINA_PROP","configForState","newState","newStateObj","childListener","_child","concat","inputDef","clientMeta","handlerName","handler","action","currentState","stateObj","eventPayload","delegatedTo","curState","curStateObj","_onExit","fromState","toState","_onEnter","processQueue","attemptedState","deferUntilTransition","stateName","queued","type","untilState","queuedArgs","deferAndTransition","filterFn","item","toProcess","filter","difference","bind","clearQueue","name","evnt","compositeState"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,WACA,kBAAAC,SAAAA,OAAAC,IACAD,QAAA,UAAAJ,GACA,gBAAAC,SACAA,QAAA,QAAAD,EAAAG,QAAA,WAEAJ,EAAA,QAAAC,EAAAD,EAAA,KACCO,KAAA,SAAAC,GACD,MCOgB,UAAUC,GCb1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAQ,GAGAP,EAAAW,QAAA,EAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDuBM,SAAUP,EAAQD,EAASQ,GE7DjC,GAAAS,GAAAT,EAAA,GACAU,EAAAV,EAAA,EAEAP,GAAAD,QAAAiB,EAAAE,MAAAD,EAAAE,UACAC,IAAAb,EAAA,GACAc,cAAAd,EAAA,GACAe,MAAAf,EAAA,GACAgB,gBACAC,cFsEM,SAAUxB,EAAQD,GG9ExBC,EAAAD,QAAAM,GHoFM,SAAUL,EAAQD,EAASQ,GIjFjC,QAAAkB,KACA,OACAC,KAAA,SAAAC,GACA,GAAAC,GAAAN,EAAAO,gBAAAC,UACA1B,MAAAmB,eAAA,MACAP,EAAAe,KAAA3B,KAAAmB,eAAA,KAAA,SAAAS,GACA,GAAA5B,KAAA6B,YAGA,IACAD,EAAAE,MAAA9B,KAAAwB,GACO,MAAAO,GAEPC,SAAA,mBAAAA,SAAAC,KACAD,QAAAC,IAAAF,EAAAG,WAPAN,GAAAE,MAAA9B,KAAAwB,IAWKxB,MAELA,KAAAmB,eAAAI,IACAX,EAAAe,KAAA3B,KAAAmB,eAAAI,GAAA,SAAAK,GACA,GAAA5B,KAAA6B,YAGA,IACAD,EAAAE,MAAA9B,KAAAwB,EAAAW,MAAA,IACO,MAAAJ,GAEPC,SAAA,mBAAAA,SAAAC,KACAD,QAAAC,IAAAF,EAAAG,WAPAN,GAAAE,MAAA9B,KAAAwB,EAAAW,MAAA,KAWKnC,OAILoC,GAAA,SAAAb,EAAAK,GACA,GAAAS,GAAArC,IAMA,OALAqC,GAAAlB,eAAAkB,EAAAlB,iBAAiDmB,QACjDD,EAAAlB,eAAAI,KACAc,EAAAlB,eAAAI,OAEAc,EAAAlB,eAAAI,GAAAgB,KAAAX,IAEAL,UAAAA,EACAK,SAAAA,EACAY,IAAA,WACAH,EAAAG,IAAAjB,EAAAK,MAKAY,IAAA,SAAAjB,EAAAK,GACA5B,KAAAmB,eAAAnB,KAAAmB,iBAAiDmB,QACjDf,EAIAvB,KAAAmB,eAAAI,GADAK,EACAhB,EAAA6B,QAAAzC,KAAAmB,eAAAI,GAAAK,MAHA5B,KAAAmB,oBA5DA,GAAAD,GAAAf,EAAA,GACAS,EAAAT,EAAA,EAuEAP,GAAAD,SACA0B,YAAAA,EACAN,SAAAM,MJ4FM,SAAUzB,EAAQD,EAASQ,GK3JjC,QAAAuC,KACA,OACAC,aAAA,gBACAxB,gBACAmB,QAEAM,UACAC,UAAAC,IACAjB,aAAA,EACAkB,aACAC,uBAIA,QAAAC,KACA,OACAC,cACAC,kBAAA,GACAC,MAAAC,OACAC,WAAAD,OACAE,YAAA,GACAC,cAAA,GACAC,kBAAAJ,OACAK,eAAA,GAIA,QAAAjC,GAAAD,EAAAmC,GAEA,IAAA,GADAC,MACAC,EAAAF,GAAA,EAAiCE,EAAArC,EAAAsC,OAAiBD,IAClDD,EAAAC,GAAArC,EAAAqC,EAEA,OAAAD,GAUA,QAAAG,GAAAC,GACA,GAAAA,EAAA,CAGA,GAAAC,KAgBA,OAfA,gBAAAD,GAEAA,EAAAtE,SACAuE,EAAAD,EACAC,EAAAlD,SAAAkD,EAAAvE,WAGAuE,EAAAvE,QAAA,WACA,MAAAsE,IAGE,kBAAAA,KACFC,EAAAvE,QAAAsE,GAEAC,EAAAlD,SAAAkD,EAAAvE,UACAuE,GAGA,QAAAC,GAAAC,EAAAC,GAGA,MAAAA,GAAAhC,GAAA,IAAA,SAAAb,EAAA8C,GACA,OAAA9C,GACA,IAAA+C,GAAAC,WACAF,EAAAG,QAAAH,EAAAI,WAAAJ,EAAAxB,YAAAsB,EAAAtB,YAEAwB,EAAA7C,KAAA,GAAAkD,UAAA,GAGA,WAAAL,EAAAM,WACAR,EAAAS,OAAA9C,MAAAqC,EAAAE,EAAA7C,KAEA,MACA,KAAA8C,GAAAO,SACA,GAAAL,GAAAH,EAAAG,MACAA,IAAAL,EAAAnB,mBAAAwB,UACAL,GAAAnB,mBAAAwB,GAEAL,EAAA7C,KAAAC,EAAA8C,EACA,MACA,SACAF,EAAA7C,KAAAC,EAAA8C,MAuEA,QAAAS,KAGA,IAAA,GAFAC,MACAC,EAAA,mBACAnB,EAAA,EAAiB,GAAAA,EAAQA,IACzBkB,EAAAlB,GAAAmB,EAAAC,OAAAC,KAAAC,MAAA,GAAAD,KAAAE,UAAA,EAOA,OALAL,GAAA,IAAA,IAEAA,EAAA,IAAAC,EAAAC,OAAA,EAAAF,EAAA,IAAA,EAAA,GAEAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAA,IACAA,EAAAM,KAAA,IArLA,GAAAlD,MAAAA,MACAmC,EAAAnE,EAAA,GACAS,EAAAT,EAAA,GAEA2C,EAAA,WACA,GAAAwC,GAAA,CACA,OAAA,YACA,MAAA,OAAAA,QAqGAC,GAAA,SAAA,gBACAC,EAAA,SAAAC,EAAAC,GACA,GACAvB,GADAwB,EAAA3F,KAEA4F,KACAC,EAAA,YAsDA,OAhDA1B,GADAsB,GAAAA,EAAAK,eAAA,eACAL,EAAAM,YAOA,WACA,GAAAvE,GAAAW,EAAA3B,KAAAkB,UAAA,EACAF,GAAA,GAAAA,EAAA,MACA,IAAAwE,GACAC,EAAAzE,EAAA,GAAAoB,UACAoD,GAAApF,EAAAE,MAAAF,EAAAsF,UAAAN,IAAoDhD,OAAAqD,IACpDD,EAAArD,aAAAnB,EAAA,GAAAmB,cAAA3C,KAAA2C,aACA/B,EAAA4E,OAAAhE,EAAA,GAAAwE,GACAL,EAAA7D,MAAA9B,KAAAwB,IAKAZ,EAAAE,MAAAqD,EAAAwB,GAIAE,EAAAM,UAAAR,EAAAQ,UACAhC,EAAAgC,UAAA,GAAAN,GAIAJ,IACA7E,EAAA4E,OAAArB,EAAAgC,UAAAV,GACA7E,EAAAE,MAAA8E,EAAAhF,EAAAwF,UAAAX,EAAA,SAAAY,EAAAC,EAAAC,GACA,KAAAhB,EAAAiB,QAAAD,KACAF,EAAAE,GAAAD,OAMAZ,GACA9E,EAAAE,MAAAqD,EAAAuB,GAIAvB,EAAAgC,UAAAJ,YAAA5B,EAGAA,EAAAsC,UAAAd,EAAAQ,UACAhC,EAiBAvE,GAAAD,SACAmF,WAAAA,EACAU,OAAAA,EACA9C,4BAAAA,EACAgE,kBAAAhE,EACAO,qBAAAA,EACAc,oBAAAA,EACAtC,gBAAAA,EACAyC,cAAAA,EACApB,iBAAAA,IL8KM,SAAUlD,EAAQD,GM/WxBC,EAAAD,SACAgH,gBAAA,aACA9B,SAAA,WACA+B,QAAA,UACArC,WAAA,YACAsC,WAAA,aACAC,aAAA,eACAC,cAAA,eACAC,SAAA,WACAC,QAAA,WNuXM,SAAUrH,EAAQD,EAASQ,GOhYjC,GAAAc,GAAAd,EAAA,GACAe,EAAAf,EAAA,GACAS,EAAAT,EAAA,GAEAa,GACA+E,YAAA,WACA9E,EAAAa,MAAA9B,KAAA0B,WACA1B,KAAAkH,oBAEAC,WAAA,WACA,GAAAxE,GAAA3C,KAAA2C,YACA,KAAAA,EACA,KAAA,IAAAyE,OAAA,iDAEA,KAAApH,KAAA4C,OAAAD,GACA,KAAA,IAAAyE,OAAA,mEAEApH,MAAAqH,WAAA1E,IAEAuE,iBAAA,WAMA,MALAlH,MAAAsH,WACAtH,KAAAsH,UAAA,EACA1G,EAAA2G,SAAAvH,KAAAY,EAAAsF,UAAAhF,EAAA+B,yBACAjD,KAAAmH,cAEAnH,MAGAwH,gBAAA,SAAAhG,GACA,GAAAiG,GAAAjG,CAQA,OALA,gBAAAiG,GAAA,IAAA,aAAAA,GAAA,IAAAA,EAAA,KAAAzH,MAEG,gBAAAyH,GAAA,IAAA,gBAAAA,GAAA,IAAA,aAAAA,GAAA,KACHA,EAAAC,QAAA1H,MAFAyH,EAAAE,OAAA,EAAA,EAAA3H,MAIAyH,GAGAG,eAAA,SAAApG,EAAAqG,GAIA,GAAAJ,GAAAjG,EACAsG,EAAAL,EAAA,EAIA,OAHA,gBAAA9C,YACA8C,EAAAE,OAAA,EAAA,EAAAG,EAAAnD,WAGA8C,EAAAtF,MADA0F,EACA,EACA,IAGAE,qBAAA,SAAAvG,EAAAwG,GACA,MAAAxG,IAIAyG,kBAAA,WACA,GAAAzG,GAAAxB,KAAAwH,gBAAAtG,EAAAO,gBAAAC,YACA2C,EAAA7C,EAAA,EACA,OAAAZ,GAAAsH,cAAA7D,GACAzD,EAAA4E,OAAAnB,GAA2BxB,UAAA7C,KAAA6C,aAEhBwB,KAAAA,GAAA,KAAAxB,UAAA7C,KAAA6C,YAKXjC,GAAAe,MACA,SACA,aACA,uBACA,eACA,cACA,SAAAwG,GACAnH,EAAAmH,GAAA,WACA,GAAA3G,GAAAxB,KAAAwH,gBAAAtG,EAAAO,gBAAAC,WACA,OAAAT,GAAAkF,UAAAgC,GAAArG,MAAA9B,KAAAwB,MAIAR,EAAAC,EAAAuE,OAAAxE,GAEApB,EAAAD,QAAAqB,GPuYM,SAAUpB,EAAQD,EAASQ,GQpdjC,QAAAc,GAAAmH,GACAxH,EAAA4E,OAAAxF,KAAAoI,GACAxH,EAAA2G,SAAAvH,KAAAkB,EAAAwB,+BACA1C,KAAAqI,WAAAvG,MAAA9B,KAAA0B,WACA4G,EAAAhH,KAAAgD,EAAA2C,QAAAjH,MAZA,GAAAY,GAAAT,EAAA,GACAe,EAAAf,EAAA,GACAU,EAAAV,EAAA,GACAmI,EAAAzH,EAAAE,SACAuD,EAAAnE,EAAA,GAEAoI,EAAA,aASA3H,GAAA4E,OAAAvE,EAAAkF,WACAkC,WAAA,aAEAlB,WAAA,SAAAa,GACA,GAAArF,GAAA3C,KAAA2C,YACA,KAAAA,EACA,KAAA,IAAAyE,OAAA,iDAEA,KAAApH,KAAA4C,OAAAD,GACA,KAAA,IAAAyE,OAAA,mEAEApH,MAAAqH,WAAAW,EAAArF,IAGA6F,eAAA,SAAAC,GACA,GACArE,GADAsE,EAAA1I,KAAA4C,OAAA6F,EAcA,OAZA7H,GAAAe,KAAA3B,KAAA+C,UAAA,SAAA4F,EAAApC,GACAoC,GAAA,kBAAAA,GAAAnG,KACAmG,EAAAnG,QAIAkG,EAAAE,SACAF,EAAAE,OAAA1H,EAAA6C,oBAAA2E,EAAAE,QACAxE,EAAAsE,EAAAE,QAAAF,EAAAE,OAAA7H,SACAf,KAAA+C,UAAAqB,EAAAvB,WAAA3B,EAAAgD,cAAAlE,KAAAoE,IAGAA,GAGA8C,iBAAA,SAAAc,GACA,GAAA,gBAAAA,GACA,KAAA,IAAAZ,OAAA,mCAOA,OALAY,GAAAO,GAAAP,EAAAO,OACAP,EAAAO,GAAAvI,KAAA6C,aACAmF,EAAAO,GAAAvI,KAAA6C,WAAAjC,EAAAsF,UAAAhF,EAAA+B,wBACAjD,KAAAmH,WAAAa,IAEAA,EAAAO,GAAAvI,KAAA6C,YAGAoF,kBAAA,SAAAD,EAAA3D,GACA,MAAAzD,GAAAsH,cAAA7D,GACAzD,EAAA4E,OAAAnB,GAA2B2D,OAAAA,EAAAnF,UAAA7C,KAAA6C,aAEhBmF,OAAAA,EAAA3D,KAAAA,GAAA,KAAAxB,UAAA7C,KAAA6C,YAIX+E,eAAA,SAAApG,EAAAqG,GAIA,GAAAJ,GAAAjG,EAAAW,MAAA,GACA2F,EAAAL,EAAA,EAIA,OAHA,gBAAAK,IACAL,EAAAE,OAAA,EAAA,EAAAG,EAAAnD,WAEAkD,EACAJ,GACAA,EAAA,IAAAoB,OAAApB,EAAAtF,MAAA,KAGA4F,qBAAA,SAAAvG,EAAAwG,GACA,OAAAA,GAAAa,OAAArH,IAGAoD,OAAA,SAAAoD,EAAAF,GACA,GAAAgB,GAAAhB,CACA,IAAA,mBAAAA,GACA,KAAA,IAAAV,OAAA,4GAEA,iBAAAU,KACAgB,GAAenE,UAAAmD,EAAArD,WAAA,EAAAD,OAAAnB,QAEf,IAAA0F,GAAA/I,KAAAkH,iBAAAc,GACAxG,EAAAN,EAAAO,gBAAAC,UACA,iBAAAoG,IACAtG,EAAAmG,OAAA,EAAA,EAAAmB,GAEAC,EAAAtF,kBAAAjC,EAAAW,MAAA,EACA,IAEA6G,GACAC,EAEA7E,EACAR,EACAsF,EAPAC,EAAAJ,EAAA3F,MACAgG,EAAApJ,KAAA4C,OAAAuG,GAGAtB,GAAA,CAIA,KAAAkB,EAAArF,cAEA,GADAU,EAAApE,KAAAwI,eAAAW,IACA/E,GAAApE,KAAAgD,mBAAA8F,EAAAtE,SAAAsE,EAAApE,SAOI,CACJoE,EAAAtE,QAAAxE,KAAAgD,mBAAA8F,EAAAtE,eACAxE,MAAAgD,mBAAA8F,EAAAtE,QAEAwE,EAAAI,EAAAN,EAAAnE,WAAAmE,EAAAnE,UAAA,IACAkD,EAAA,MAAAmB,EACAC,EAAAG,EAAAJ,IAAAhJ,KAAAgJ,IAAAhJ,KAAA,KACAkJ,EAAAH,EAAA3F,MAAA,IAAA4F,EACAD,EAAAvF,cAAA0F,CACA,IAAAG,GAAArJ,KAAAiI,kBACAD,GACMrD,UAAAmE,EAAAnE,UAAAF,UAAAqE,EAAArE,UAAAD,OAAAsE,EAAAtE,QAENyE,IAGAjJ,KAAAsB,KAAAgD,EAAAO,SAAAwE,GACA,kBAAAJ,GACArF,EAAAqF,EAAAnH,MAAA9B,KAAAA,KAAA4H,eAAApG,EAAAqG,KAEAjE,EAAAqF,EACAjJ,KAAAqH,WAAAW,EAAAiB,IAEAjJ,KAAAsB,KAAAgD,EAAAsC,QAAAyC,IATArJ,KAAAsB,KAAAgD,EAAAC,WAAA3D,EAAA4E,QAA8ChE,KAAAA,GAAa6H,IAW3DN,EAAAxF,YAAAwF,EAAAvF,cACAuF,EAAAvF,cAAA,GACAuF,EAAAtF,kBAAAJ,WAjCAyF,GAAAtE,OAAAsE,EAAAtE,QAAAtD,EAAA4D,aACAgE,EAAArE,WAAA,EACAzE,KAAAgD,mBAAA8F,EAAAtE,SAAkD8E,YAAAlF,EAAAvB,WAGlDe,EAAAQ,EAAAQ,OAAA9C,MAAAsC,EAAA5C,EA+BA,OAAAoC,IAGAyD,WAAA,SAAAW,EAAAS,GACA,GAIArE,GAJA2E,EAAA/I,KAAAkH,iBAAAc,GACAuB,EAAAR,EAAA3F,MACAoG,EAAAxJ,KAAA4C,OAAA2G,GACAb,EAAA1I,KAAA4C,OAAA6F,GAEAjH,EAAAN,EAAAO,gBAAAC,WAAAS,MAAA,EACA,KAAA4G,EAAArF,eAAA+E,IAAAc,EAAA,CACA,GAAAb,EAAA,CACAtE,EAAApE,KAAAwI,eAAAC,GACAe,GAAAA,EAAAC,UACAV,EAAArF,eAAA,EACA8F,EAAAC,QAAAjJ,KAAAR,KAAAgI,GACAe,EAAArF,eAAA,GAEAqF,EAAA5F,kBAAAsF,EACAM,EAAAzF,WAAAiG,EACAR,EAAA3F,MAAAqF,CACA,IAAAY,GAAArJ,KAAAiI,kBAAAD,GACA0B,UAAAX,EAAAzF,WACA4F,OAAAH,EAAAvF,cACAmG,QAAAlB,GAcA,OAZAzI,MAAAsB,KAAAgD,EAAAuC,WAAAwC,GACAX,EAAAkB,UACAlB,EAAAkB,SAAA9H,MAAA9B,KAAAA,KAAA+H,qBAAAvG,EAAAwG,IAEAhI,KAAAsB,KAAAgD,EAAAwC,aAAAuC,GACAjF,GACAA,EAAAQ,OAAAoD,EAAA,eAGAe,EAAA5F,oBAAAsF,GACAzI,KAAA6J,aAAA7B,EAAA1D,EAAAqC,kBAIA3G,KAAAsB,KAAAgD,EAAAyC,cAAA/G,KAAAiI,kBAAAD,GACA5E,MAAA2F,EAAA3F,MACA0G,eAAArB,OAKAsB,qBAAA,SAAA/B,EAAAgC,GACA,GAAAjB,GAAA/I,KAAAkH,iBAAAc,EACA,IAAAe,EAAAtF,kBAAA,CACA,GAAAwG,IACAC,KAAA5F,EAAAqC,gBACAwD,WAAAH,EACAxI,KAAAuH,EAAAtF,kBAEAsF,GAAA7F,WAAAX,KAAA0H,EACA,IAAAZ,GAAArJ,KAAAiI,kBAAAD,GACA5E,MAAA2F,EAAA3F,MACAgH,WAAAH,GAEAjK,MAAAsB,KAAAgD,EAAA0C,SAAAqC,KAIAgB,mBAAA,SAAArC,EAAAgC,GACAhK,KAAA+J,qBAAA/B,EAAAgC,GACAhK,KAAAqH,WAAAW,EAAAgC,IAGAH,aAAA,SAAA7B,GACA,GAAAe,GAAA/I,KAAAkH,iBAAAc,GACAsC,EAAA,SAAAC,GACA,OAAAA,EAAAJ,YAAAI,EAAAJ,aAAApB,EAAA3F,OAEAoH,EAAA5J,EAAA6J,OAAA1B,EAAA7F,WAAAoH,EACAvB,GAAA7F,WAAAtC,EAAA8J,WAAA3B,EAAA7F,WAAAsH,GACA5J,EAAAe,KAAA6I,EAAA,SAAAD,GACAvK,KAAA4E,OAAA9C,MAAA9B,MAAAgI,GAAAa,OAAA0B,EAAA/I,QACGmJ,KAAA3K,QAGH4K,WAAA,SAAA5C,EAAA6C,GACA,GAAA9B,GAAA/I,KAAAkH,iBAAAc,EACA,IAAA6C,EAEG,CACH,GAAAJ,GAAA,SAAAK,GACA,MAAAD,GAAAC,EAAAX,aAAAU,GAAA,EAEA9B,GAAA7F,WAAAtC,EAAA6J,OAAA1B,EAAA7F,WAAAuH,OALA1B,GAAA7F,eASA6H,eAAA,SAAA/C,GACA,GAAAe,GAAA/I,KAAAkH,iBAAAc,GACA5E,EAAA2F,EAAA3F,MACAgB,EAAApE,KAAA4C,OAAAQ,GAAAwF,QAAA5I,KAAA4C,OAAAQ,GAAAwF,OAAA7H,QAIA,OAHAqD,KACAhB,GAAA,IAAAgB,EAAA2G,eAAA/C,IAEA5E,IAECvC,EAAAQ,eAEDJ,EAAAuE,OAAAtE,EAAAsE,OAEA5F,EAAAD,QAAAsB","file":"machina.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n *  * machina - A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.\n *  * Author: Jim Cowart (http://ifandelse.com)\n *  * Version: v2.0.2\n *  * Url: http://machina-js.org/\n *  * License(s): \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar emitter = __webpack_require__( 2 );\n\t\n\tmodule.exports = _.merge( emitter.instance, {\n\t\tFsm: __webpack_require__( 5 ),\n\t\tBehavioralFsm: __webpack_require__( 6 ),\n\t\tutils: __webpack_require__( 3 ),\n\t\teventListeners: {\n\t\t\tnewFsm: []\n\t\t}\n\t} );\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar utils = __webpack_require__( 3 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tfunction getInstance() {\n\t\treturn {\n\t\t\temit: function( eventName ) {\n\t\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ton: function( eventName, callback ) {\n\t\t\t\tvar self = this;\n\t\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\t\treturn {\n\t\t\t\t\teventName: eventName,\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\toff: function() {\n\t\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\toff: function( eventName, callback ) {\n\t\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !eventName ) {\n\t\t\t\t\tthis.eventListeners = {};\n\t\t\t\t} else {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tmodule.exports = {\n\t\tgetInstance: getInstance,\n\t\tinstance: getInstance()\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar slice = [].slice;\n\tvar events = __webpack_require__( 4 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar makeFsmNamespace = ( function() {\n\t\tvar machinaCount = 0;\n\t\treturn function() {\n\t\t\treturn \"fsm.\" + machinaCount++;\n\t\t};\n\t} )();\n\t\n\tfunction getDefaultBehavioralOptions() {\n\t\treturn {\n\t\t\tinitialState: \"uninitialized\",\n\t\t\teventListeners: {\n\t\t\t\t\"*\": []\n\t\t\t},\n\t\t\tstates: {},\n\t\t\tnamespace: makeFsmNamespace(),\n\t\t\tuseSafeEmit: false,\n\t\t\thierarchy: {},\n\t\t\tpendingDelegations: {}\n\t\t};\n\t}\n\t\n\tfunction getDefaultClientMeta() {\n\t\treturn {\n\t\t\tinputQueue: [],\n\t\t\ttargetReplayState: \"\",\n\t\t\tstate: undefined,\n\t\t\tpriorState: undefined,\n\t\t\tpriorAction: \"\",\n\t\t\tcurrentAction: \"\",\n\t\t\tcurrentActionArgs: undefined,\n\t\t\tinExitHandler: false\n\t\t};\n\t}\n\t\n\tfunction getLeaklessArgs( args, startIdx ) {\n\t\tvar result = [];\n\t\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\t\tresult[ i ] = args[ i ];\n\t\t}\n\t\treturn result;\n\t}\n\t/*\n\t\thandle ->\n\t\t\tchild = stateObj._child && stateObj._child.instance;\n\t\n\t\ttransition ->\n\t\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t*/\n\tfunction getChildFsmInstance( config ) {\n\t\tif ( !config ) {\n\t\t\treturn;\n\t\t}\n\t\tvar childFsmDefinition = {};\n\t\tif ( typeof config === \"object\" ) {\n\t\t\t// is this a config object with a factory?\n\t\t\tif ( config.factory ) {\n\t\t\t\tchildFsmDefinition = config;\n\t\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t\t} else {\n\t\t\t\t// assuming this is a machina instance\n\t\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\t\treturn config;\n\t\t\t\t};\n\t\t\t}\n\t\t} else if ( typeof config === \"function\" ) {\n\t\t\tchildFsmDefinition.factory = config;\n\t\t}\n\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\treturn childFsmDefinition;\n\t}\n\t\n\tfunction listenToChild( fsm, child ) {\n\t\t// Need to investigate potential for discarded event\n\t\t// listener memory leak in long-running, deeply-nested hierarchies.\n\t\treturn child.on( \"*\", function( eventName, data ) {\n\t\t\tswitch ( eventName ) {\n\t\t\t\tcase events.NO_HANDLER:\n\t\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t\t}\n\t\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase events.HANDLING :\n\t\t\t\t\tvar ticket = data.ticket;\n\t\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t\t}\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\t}\n\t\n\t// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n\t// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n\t// that share the same extended prototype won't share state *on* those prototypes.\n\tvar _machKeys = [ \"states\", \"initialState\" ];\n\tvar extend = function( protoProps, staticProps ) {\n\t\tvar parent = this;\n\t\tvar fsm; // placeholder for instance constructor\n\t\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\t\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\t\n\t\t// The constructor function for the new subclass is either defined by you\n\t\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t\t// by us to simply call the parent's constructor.\n\t\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\t\tfsm = protoProps.constructor;\n\t\t} else {\n\t\t\t// The default machina constructor (when using inheritance) creates a\n\t\t\t// deep copy of the states/initialState values from the prototype and\n\t\t\t// extends them over the instance so that they'll be instance-level.\n\t\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t\t// value will be preferred over any data pulled up from the prototype.\n\t\t\tfsm = function() {\n\t\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\t\tvar blendedState;\n\t\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\t\tparent.apply( this, args );\n\t\t\t};\n\t\t}\n\t\n\t\t// Inherit class (static) properties from parent.\n\t\t_.merge( fsm, parent );\n\t\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tCtor.prototype = parent.prototype;\n\t\tfsm.prototype = new Ctor();\n\t\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif ( protoProps ) {\n\t\t\t_.extend( fsm.prototype, protoProps );\n\t\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\t\taccum[ key ] = val;\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\t\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif ( staticProps ) {\n\t\t\t_.merge( fsm, staticProps );\n\t\t}\n\t\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tfsm.prototype.constructor = fsm;\n\t\n\t\t// Set a convenience property in case the parent's prototype is needed later.\n\t\tfsm.__super__ = parent.prototype;\n\t\treturn fsm;\n\t};\n\t\n\tfunction createUUID() {\n\t\tvar s = [];\n\t\tvar hexDigits = \"0123456789abcdef\";\n\t\tfor ( var i = 0; i < 36; i++ ) {\n\t\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t\t}\n\t\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t\t/* jshint ignore:start */\n\t\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t\t/* jshint ignore:end */\n\t\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\t\treturn s.join( \"\" );\n\t}\n\t\n\tmodule.exports = {\n\t\tcreateUUID: createUUID,\n\t\textend: extend,\n\t\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultClientMeta: getDefaultClientMeta,\n\t\tgetChildFsmInstance: getChildFsmInstance,\n\t\tgetLeaklessArgs: getLeaklessArgs,\n\t\tlistenToChild: listenToChild,\n\t\tmakeFsmNamespace: makeFsmNamespace\n\t};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\tNEXT_TRANSITION: \"transition\",\n\t\tHANDLING: \"handling\",\n\t\tHANDLED: \"handled\",\n\t\tNO_HANDLER: \"nohandler\",\n\t\tTRANSITION: \"transition\",\n\t\tTRANSITIONED: \"transitioned\",\n\t\tINVALID_STATE: \"invalidstate\",\n\t\tDEFERRED: \"deferred\",\n\t\tNEW_FSM: \"newfsm\"\n\t};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BehavioralFsm = __webpack_require__( 6 );\n\tvar utils = __webpack_require__( 3 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar Fsm = {\n\t\tconstructor: function() {\n\t\t\tBehavioralFsm.apply( this, arguments );\n\t\t\tthis.ensureClientMeta();\n\t\t},\n\t\tinitClient: function initClient() {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( initialState );\n\t\t},\n\t\tensureClientMeta: function ensureClientMeta() {\n\t\t\tif ( !this._stamped ) {\n\t\t\t\tthis._stamped = true;\n\t\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\t\tthis.initClient();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\tensureClientArg: function( args ) {\n\t\t\tvar _args = args;\n\t\t\t// we need to test the args and verify that if a client arg has\n\t\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t\t_args.splice( 0, 1, this );\n\t\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t\t_args.unshift( this );\n\t\t\t}\n\t\t\treturn _args;\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args;\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args.slice( 1 ) :\n\t\t\t\t_args.slice( 2 );\n\t\t},\n\t\n\t\tgetSystemHandlerArgs: function( args, client ) {\n\t\t\treturn args;\n\t\t},\n\t\n\t\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\t\tbuildEventPayload: function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\tvar data = args[ 1 ];\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_.each( [\n\t\t\"handle\",\n\t\t\"transition\",\n\t\t\"deferUntilTransition\",\n\t\t\"processQueue\",\n\t\t\"clearQueue\"\n\t], function( methodWithClientInjected ) {\n\t\tFsm[ methodWithClientInjected ] = function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t\t};\n\t} );\n\t\n\tFsm = BehavioralFsm.extend( Fsm );\n\t\n\tmodule.exports = Fsm;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar utils = __webpack_require__( 3 );\n\tvar emitter = __webpack_require__( 2 );\n\tvar topLevelEmitter = emitter.instance;\n\tvar events = __webpack_require__( 4 );\n\t\n\tvar MACHINA_PROP = \"__machina__\";\n\t\n\tfunction BehavioralFsm( options ) {\n\t\t_.extend( this, options );\n\t\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\t\tthis.initialize.apply( this, arguments );\n\t\ttopLevelEmitter.emit( events.NEW_FSM, this );\n\t}\n\t\n\t_.extend( BehavioralFsm.prototype, {\n\t\tinitialize: function() {},\n\t\n\t\tinitClient: function initClient( client ) {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( client, initialState );\n\t\t},\n\t\n\t\tconfigForState: function configForState( newState ) {\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\t\tchildListener.off();\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tif ( newStateObj._child ) {\n\t\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t\t}\n\t\n\t\t\treturn child;\n\t\t},\n\t\n\t\tensureClientMeta: function ensureClientMeta( client ) {\n\t\t\tif ( typeof client !== \"object\" ) {\n\t\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t\t}\n\t\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\t\tthis.initClient( client );\n\t\t\t}\n\t\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t\t},\n\t\n\t\tbuildEventPayload: function( client, data ) {\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args.slice( 0 );\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof input === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args :\n\t\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t\t},\n\t\n\t\tgetSystemHandlerArgs: function( args, client ) {\n\t\t\treturn [ client ].concat( args );\n\t\t},\n\t\n\t\thandle: function( client, input ) {\n\t\t\tvar inputDef = input;\n\t\t\tif ( typeof input === \"undefined\" ) {\n\t\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t\t}\n\t\t\tif ( typeof input === \"string\" ) {\n\t\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t\t}\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( typeof input !== \"object\" ) {\n\t\t\t\targs.splice( 1, 1, inputDef );\n\t\t\t}\n\t\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\t\tvar currentState = clientMeta.state;\n\t\t\tvar stateObj = this.states[ currentState ];\n\t\t\tvar handlerName;\n\t\t\tvar handler;\n\t\t\tvar isCatchAll = false;\n\t\t\tvar child;\n\t\t\tvar result;\n\t\t\tvar action;\n\t\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\t\tchild = this.configForState( currentState );\n\t\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\t\tinputDef.delegated = true;\n\t\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t\t} else {\n\t\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t\t}\n\t\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t\t);\n\t\t\t\t\tif ( !handler ) {\n\t\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t\t\tclientMeta.currentActionArgs = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\n\t\ttransition: function( client, newState ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar curState = clientMeta.state;\n\t\t\tvar curStateObj = this.states[ curState ];\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\tvar args = utils.getLeaklessArgs( arguments ).slice( 2 );\n\t\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\t\tif ( newStateObj ) {\n\t\t\t\t\tchild = this.configForState( newState );\n\t\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\t\tclientMeta.state = newState;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\t\ttoState: newState\n\t\t\t\t\t} );\n\t\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\t\tnewStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( events.TRANSITIONED, eventPayload );\n\t\t\t\t\tif ( child ) {\n\t\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tattemptedState: newState\n\t\t\t\t} ) );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferUntilTransition: function( client, stateName ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\t\tvar queued = {\n\t\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\t\tuntilState: stateName,\n\t\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tqueuedArgs: queued\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferAndTransition: function( client, stateName ) {\n\t\t\tthis.deferUntilTransition( client, stateName );\n\t\t\tthis.transition( client, stateName );\n\t\t},\n\t\n\t\tprocessQueue: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar filterFn = function( item ) {\n\t\t\t\treturn ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );\n\t\t\t};\n\t\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t\t_.each( toProcess, function( item ) {\n\t\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t\t}.bind( this ) );\n\t\t},\n\t\n\t\tclearQueue: function( client, name ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tif ( !name ) {\n\t\t\t\tclientMeta.inputQueue = [];\n\t\t\t} else {\n\t\t\t\tvar filter = function( evnt ) {\n\t\t\t\t\treturn ( name ? evnt.untilState !== name : true );\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t\t}\n\t\t},\n\t\n\t\tcompositeState: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar state = clientMeta.state;\n\t\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\t\tif ( child ) {\n\t\t\t\tstate += \".\" + child.compositeState( client );\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t}, emitter.getInstance() );\n\t\n\tBehavioralFsm.extend = utils.extend;\n\t\n\tmodule.exports = BehavioralFsm;\n\n\n/***/ })\n/******/ ])\n});\n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhY2NhOTQxZDVhNDg3MDEyNzkxYSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFjaGluYS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiX1wiLFwiY29tbW9uanNcIjpcImxvZGFzaFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2hcIixcImFtZFwiOlwibG9kYXNoXCJ9Iiwid2VicGFjazovLy8uL3NyYy9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9Gc20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JlaGF2aW9yYWxGc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ1ZELGdEOzs7Ozs7QUNBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBIiwiZmlsZSI6Im1hY2hpbmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibG9kYXNoXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm1hY2hpbmFcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIm1hY2hpbmFcIl0gPSBmYWN0b3J5KHJvb3RbXCJfXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFjY2E5NDFkNWE0ODcwMTI3OTFhIiwidmFyIF8gPSByZXF1aXJlKCBcImxvZGFzaFwiICk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoIFwiLi9lbWl0dGVyXCIgKTtcblxubW9kdWxlLmV4cG9ydHMgPSBfLm1lcmdlKCBlbWl0dGVyLmluc3RhbmNlLCB7XG5cdEZzbTogcmVxdWlyZSggXCIuL0ZzbVwiICksXG5cdEJlaGF2aW9yYWxGc206IHJlcXVpcmUoIFwiLi9CZWhhdmlvcmFsRnNtXCIgKSxcblx0dXRpbHM6IHJlcXVpcmUoIFwiLi91dGlsc1wiICksXG5cdGV2ZW50TGlzdGVuZXJzOiB7XG5cdFx0bmV3RnNtOiBbXVxuXHR9XG59ICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWNoaW5hLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiX1wiLFwiY29tbW9uanNcIjpcImxvZGFzaFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2hcIixcImFtZFwiOlwibG9kYXNoXCJ9XG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlscyA9IHJlcXVpcmUoIFwiLi91dGlsc1wiICk7XG52YXIgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG5cdHJldHVybiB7XG5cdFx0ZW1pdDogZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdHZhciBhcmdzID0gdXRpbHMuZ2V0TGVha2xlc3NBcmdzKCBhcmd1bWVudHMgKTtcblx0XHRcdGlmICggdGhpcy5ldmVudExpc3RlbmVyc1sgXCIqXCIgXSApIHtcblx0XHRcdFx0Xy5lYWNoKCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBcIipcIiBdLCBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy51c2VTYWZlRW1pdCApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0XHRcdFx0XHRcdFx0aWYgKCBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLmxvZyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggZXhjZXB0aW9uLnN0YWNrICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gKSB7XG5cdFx0XHRcdF8uZWFjaCggdGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0sIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzLnVzZVNhZmVFbWl0ICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3Muc2xpY2UoIDEgKSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgYXJncy5zbGljZSggMSApICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0XHRcdFx0XHRcdFx0aWYgKCBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLmxvZyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggZXhjZXB0aW9uLnN0YWNrICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b246IGZ1bmN0aW9uKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5ldmVudExpc3RlbmVycyA9IHNlbGYuZXZlbnRMaXN0ZW5lcnMgfHwgeyBcIipcIjogW10gfTtcblx0XHRcdGlmICggIXNlbGYuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdICkge1xuXHRcdFx0XHRzZWxmLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0ucHVzaCggY2FsbGJhY2sgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV2ZW50TmFtZTogZXZlbnROYW1lLFxuXHRcdFx0XHRjYWxsYmFjazogY2FsbGJhY2ssXG5cdFx0XHRcdG9mZjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoIGV2ZW50TmFtZSwgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0b2ZmOiBmdW5jdGlvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzIHx8IHsgXCIqXCI6IFtdIH07XG5cdFx0XHRpZiAoICFldmVudE5hbWUgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0dGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gPSBfLndpdGhvdXQoIHRoaXMuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRnZXRJbnN0YW5jZTogZ2V0SW5zdGFuY2UsXG5cdGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBldmVudHMgPSByZXF1aXJlKCBcIi4vZXZlbnRzLmpzXCIgKTtcbnZhciBfID0gcmVxdWlyZSggXCJsb2Rhc2hcIiApO1xuXG52YXIgbWFrZUZzbU5hbWVzcGFjZSA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBtYWNoaW5hQ291bnQgPSAwO1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiZnNtLlwiICsgbWFjaGluYUNvdW50Kys7XG5cdH07XG59ICkoKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zKCkge1xuXHRyZXR1cm4ge1xuXHRcdGluaXRpYWxTdGF0ZTogXCJ1bmluaXRpYWxpemVkXCIsXG5cdFx0ZXZlbnRMaXN0ZW5lcnM6IHtcblx0XHRcdFwiKlwiOiBbXVxuXHRcdH0sXG5cdFx0c3RhdGVzOiB7fSxcblx0XHRuYW1lc3BhY2U6IG1ha2VGc21OYW1lc3BhY2UoKSxcblx0XHR1c2VTYWZlRW1pdDogZmFsc2UsXG5cdFx0aGllcmFyY2h5OiB7fSxcblx0XHRwZW5kaW5nRGVsZWdhdGlvbnM6IHt9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRDbGllbnRNZXRhKCkge1xuXHRyZXR1cm4ge1xuXHRcdGlucHV0UXVldWU6IFtdLFxuXHRcdHRhcmdldFJlcGxheVN0YXRlOiBcIlwiLFxuXHRcdHN0YXRlOiB1bmRlZmluZWQsXG5cdFx0cHJpb3JTdGF0ZTogdW5kZWZpbmVkLFxuXHRcdHByaW9yQWN0aW9uOiBcIlwiLFxuXHRcdGN1cnJlbnRBY3Rpb246IFwiXCIsXG5cdFx0Y3VycmVudEFjdGlvbkFyZ3M6IHVuZGVmaW5lZCxcblx0XHRpbkV4aXRIYW5kbGVyOiBmYWxzZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRMZWFrbGVzc0FyZ3MoIGFyZ3MsIHN0YXJ0SWR4ICkge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdGZvciAoIHZhciBpID0gKCBzdGFydElkeCB8fCAwICk7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuXHRcdHJlc3VsdFsgaSBdID0gYXJnc1sgaSBdO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKlxuXHRoYW5kbGUgLT5cblx0XHRjaGlsZCA9IHN0YXRlT2JqLl9jaGlsZCAmJiBzdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2U7XG5cblx0dHJhbnNpdGlvbiAtPlxuXHRcdG5ld1N0YXRlT2JqLl9jaGlsZCA9IGdldENoaWxkRnNtSW5zdGFuY2UoIG5ld1N0YXRlT2JqLl9jaGlsZCApO1xuXHRcdGNoaWxkID0gbmV3U3RhdGVPYmouX2NoaWxkICYmIG5ld1N0YXRlT2JqLl9jaGlsZC5pbnN0YW5jZTtcbiovXG5mdW5jdGlvbiBnZXRDaGlsZEZzbUluc3RhbmNlKCBjb25maWcgKSB7XG5cdGlmICggIWNvbmZpZyApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIGNoaWxkRnNtRGVmaW5pdGlvbiA9IHt9O1xuXHRpZiAoIHR5cGVvZiBjb25maWcgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gaXMgdGhpcyBhIGNvbmZpZyBvYmplY3Qgd2l0aCBhIGZhY3Rvcnk/XG5cdFx0aWYgKCBjb25maWcuZmFjdG9yeSApIHtcblx0XHRcdGNoaWxkRnNtRGVmaW5pdGlvbiA9IGNvbmZpZztcblx0XHRcdGNoaWxkRnNtRGVmaW5pdGlvbi5pbnN0YW5jZSA9IGNoaWxkRnNtRGVmaW5pdGlvbi5mYWN0b3J5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFzc3VtaW5nIHRoaXMgaXMgYSBtYWNoaW5hIGluc3RhbmNlXG5cdFx0XHRjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSA9IGNvbmZpZztcblx0fVxuXHRjaGlsZEZzbURlZmluaXRpb24uaW5zdGFuY2UgPSBjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSgpO1xuXHRyZXR1cm4gY2hpbGRGc21EZWZpbml0aW9uO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5Ub0NoaWxkKCBmc20sIGNoaWxkICkge1xuXHQvLyBOZWVkIHRvIGludmVzdGlnYXRlIHBvdGVudGlhbCBmb3IgZGlzY2FyZGVkIGV2ZW50XG5cdC8vIGxpc3RlbmVyIG1lbW9yeSBsZWFrIGluIGxvbmctcnVubmluZywgZGVlcGx5LW5lc3RlZCBoaWVyYXJjaGllcy5cblx0cmV0dXJuIGNoaWxkLm9uKCBcIipcIiwgZnVuY3Rpb24oIGV2ZW50TmFtZSwgZGF0YSApIHtcblx0XHRzd2l0Y2ggKCBldmVudE5hbWUgKSB7XG5cdFx0XHRjYXNlIGV2ZW50cy5OT19IQU5ETEVSOlxuXHRcdFx0XHRpZiAoICFkYXRhLnRpY2tldCAmJiAhZGF0YS5kZWxlZ2F0ZWQgJiYgZGF0YS5uYW1lc3BhY2UgIT09IGZzbS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0Ly8gT2sgLSB3ZSdyZSBkZWFsaW5nIHcvIGEgY2hpbGQgaGFuZGxpbmcgaW5wdXQgdGhhdCBzaG91bGQgYnViYmxlIHVwXG5cdFx0XHRcdFx0ZGF0YS5hcmdzWyAxIF0uYnViYmxpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHdlIGRvIE5PVCBidWJibGUgX3Jlc2V0IGlucHV0cyB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdGlmICggZGF0YS5pbnB1dFR5cGUgIT09IFwiX3Jlc2V0XCIgKSB7XG5cdFx0XHRcdFx0ZnNtLmhhbmRsZS5hcHBseSggZnNtLCBkYXRhLmFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgZXZlbnRzLkhBTkRMSU5HIDpcblx0XHRcdFx0dmFyIHRpY2tldCA9IGRhdGEudGlja2V0O1xuXHRcdFx0XHRpZiAoIHRpY2tldCAmJiBmc20ucGVuZGluZ0RlbGVnYXRpb25zWyB0aWNrZXQgXSApIHtcblx0XHRcdFx0XHRkZWxldGUgZnNtLnBlbmRpbmdEZWxlZ2F0aW9uc1sgdGlja2V0IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnNtLmVtaXQoIGV2ZW50TmFtZSwgZGF0YSApOyAvLyBwb3NzaWJseSB0cmFuc2Zvcm0gcGF5bG9hZD9cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRmc20uZW1pdCggZXZlbnROYW1lLCBkYXRhICk7IC8vIHBvc3NpYmx5IHRyYW5zZm9ybSBwYXlsb2FkP1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gX21hY2hLZXlzIGFyZSBtZW1iZXJzIHdlIHdhbnQgdG8gdHJhY2sgYWNyb3NzIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgYW4gZXh0ZW5kZWQgRlNNIGNvbnN0cnVjdG9yXG4vLyBTaW5jZSB3ZSB3YW50IHRvIGV2ZW50dWFsbHkgbWVyZ2UgdGhlIGFnZ3JlZ2F0ZSBvZiB0aG9zZSB2YWx1ZXMgb250byB0aGUgaW5zdGFuY2Ugc28gdGhhdCBGU01zXG4vLyB0aGF0IHNoYXJlIHRoZSBzYW1lIGV4dGVuZGVkIHByb3RvdHlwZSB3b24ndCBzaGFyZSBzdGF0ZSAqb24qIHRob3NlIHByb3RvdHlwZXMuXG52YXIgX21hY2hLZXlzID0gWyBcInN0YXRlc1wiLCBcImluaXRpYWxTdGF0ZVwiIF07XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzICkge1xuXHR2YXIgcGFyZW50ID0gdGhpcztcblx0dmFyIGZzbTsgLy8gcGxhY2Vob2xkZXIgZm9yIGluc3RhbmNlIGNvbnN0cnVjdG9yXG5cdHZhciBtYWNoT2JqID0ge307IC8vIG9iamVjdCB1c2VkIHRvIGhvbGQgaW5pdGlhbFN0YXRlICYgc3RhdGVzIGZyb20gcHJvdG90eXBlIGZvciBpbnN0YW5jZS1sZXZlbCBtZXJnaW5nXG5cdHZhciBDdG9yID0gZnVuY3Rpb24oKSB7fTsgLy8gcGxhY2Vob2xkZXIgY3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc2VydCBsZXZlbCBpbiBwcm90b3R5cGUgY2hhaW5cblxuXHQvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG5cdC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuXHQvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG5cdGlmICggcHJvdG9Qcm9wcyAmJiBwcm90b1Byb3BzLmhhc093blByb3BlcnR5KCBcImNvbnN0cnVjdG9yXCIgKSApIHtcblx0XHRmc20gPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRoZSBkZWZhdWx0IG1hY2hpbmEgY29uc3RydWN0b3IgKHdoZW4gdXNpbmcgaW5oZXJpdGFuY2UpIGNyZWF0ZXMgYVxuXHRcdC8vIGRlZXAgY29weSBvZiB0aGUgc3RhdGVzL2luaXRpYWxTdGF0ZSB2YWx1ZXMgZnJvbSB0aGUgcHJvdG90eXBlIGFuZFxuXHRcdC8vIGV4dGVuZHMgdGhlbSBvdmVyIHRoZSBpbnN0YW5jZSBzbyB0aGF0IHRoZXknbGwgYmUgaW5zdGFuY2UtbGV2ZWwuXG5cdFx0Ly8gSWYgYW4gb3B0aW9ucyBhcmcgKGFyZ3NbMF0pIGlzIHBhc3NlZCBpbiwgYSBzdGF0ZXMgb3IgaW50aWFsU3RhdGVcblx0XHQvLyB2YWx1ZSB3aWxsIGJlIHByZWZlcnJlZCBvdmVyIGFueSBkYXRhIHB1bGxlZCB1cCBmcm9tIHRoZSBwcm90b3R5cGUuXG5cdFx0ZnNtID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXHRcdFx0YXJnc1sgMCBdID0gYXJnc1sgMCBdIHx8IHt9O1xuXHRcdFx0dmFyIGJsZW5kZWRTdGF0ZTtcblx0XHRcdHZhciBpbnN0YW5jZVN0YXRlcyA9IGFyZ3NbIDAgXS5zdGF0ZXMgfHwge307XG5cdFx0XHRibGVuZGVkU3RhdGUgPSBfLm1lcmdlKCBfLmNsb25lRGVlcCggbWFjaE9iaiApLCB7IHN0YXRlczogaW5zdGFuY2VTdGF0ZXMgfSApO1xuXHRcdFx0YmxlbmRlZFN0YXRlLmluaXRpYWxTdGF0ZSA9IGFyZ3NbIDAgXS5pbml0aWFsU3RhdGUgfHwgdGhpcy5pbml0aWFsU3RhdGU7XG5cdFx0XHRfLmV4dGVuZCggYXJnc1sgMCBdLCBibGVuZGVkU3RhdGUgKTtcblx0XHRcdHBhcmVudC5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblxuXHQvLyBJbmhlcml0IGNsYXNzIChzdGF0aWMpIHByb3BlcnRpZXMgZnJvbSBwYXJlbnQuXG5cdF8ubWVyZ2UoIGZzbSwgcGFyZW50ICk7XG5cblx0Ly8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcblx0Ly8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0Q3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuXHRmc20ucHJvdG90eXBlID0gbmV3IEN0b3IoKTtcblxuXHQvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcblx0Ly8gaWYgc3VwcGxpZWQuXG5cdGlmICggcHJvdG9Qcm9wcyApIHtcblx0XHRfLmV4dGVuZCggZnNtLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyApO1xuXHRcdF8ubWVyZ2UoIG1hY2hPYmosIF8udHJhbnNmb3JtKCBwcm90b1Byb3BzLCBmdW5jdGlvbiggYWNjdW0sIHZhbCwga2V5ICkge1xuXHRcdFx0aWYgKCBfbWFjaEtleXMuaW5kZXhPZigga2V5ICkgIT09IC0xICkge1xuXHRcdFx0XHRhY2N1bVsga2V5IF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApICk7XG5cdH1cblxuXHQvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cblx0aWYgKCBzdGF0aWNQcm9wcyApIHtcblx0XHRfLm1lcmdlKCBmc20sIHN0YXRpY1Byb3BzICk7XG5cdH1cblxuXHQvLyBDb3JyZWN0bHkgc2V0IGNoaWxkJ3MgYHByb3RvdHlwZS5jb25zdHJ1Y3RvcmAuXG5cdGZzbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBmc207XG5cblx0Ly8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZCBsYXRlci5cblx0ZnNtLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cdHJldHVybiBmc207XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVVVUlEKCkge1xuXHR2YXIgcyA9IFtdO1xuXHR2YXIgaGV4RGlnaXRzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpKysgKSB7XG5cdFx0c1sgaSBdID0gaGV4RGlnaXRzLnN1YnN0ciggTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqIDB4MTAgKSwgMSApO1xuXHR9XG5cdHNbIDE0IF0gPSBcIjRcIjsgLy8gYml0cyAxMi0xNSBvZiB0aGUgdGltZV9oaV9hbmRfdmVyc2lvbiBmaWVsZCB0byAwMDEwXG5cdC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblx0c1sgMTkgXSA9IGhleERpZ2l0cy5zdWJzdHIoICggc1sgMTkgXSAmIDB4MyApIHwgMHg4LCAxICk7IC8vIGJpdHMgNi03IG9mIHRoZSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkIHRvIDAxXG5cdC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cdHNbIDggXSA9IHNbIDEzIF0gPSBzWyAxOCBdID0gc1sgMjMgXSA9IFwiLVwiO1xuXHRyZXR1cm4gcy5qb2luKCBcIlwiICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVVVUlEOiBjcmVhdGVVVUlELFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0Z2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zOiBnZXREZWZhdWx0QmVoYXZpb3JhbE9wdGlvbnMsXG5cdGdldERlZmF1bHRPcHRpb25zOiBnZXREZWZhdWx0QmVoYXZpb3JhbE9wdGlvbnMsXG5cdGdldERlZmF1bHRDbGllbnRNZXRhOiBnZXREZWZhdWx0Q2xpZW50TWV0YSxcblx0Z2V0Q2hpbGRGc21JbnN0YW5jZTogZ2V0Q2hpbGRGc21JbnN0YW5jZSxcblx0Z2V0TGVha2xlc3NBcmdzOiBnZXRMZWFrbGVzc0FyZ3MsXG5cdGxpc3RlblRvQ2hpbGQ6IGxpc3RlblRvQ2hpbGQsXG5cdG1ha2VGc21OYW1lc3BhY2U6IG1ha2VGc21OYW1lc3BhY2Vcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TkVYVF9UUkFOU0lUSU9OOiBcInRyYW5zaXRpb25cIixcblx0SEFORExJTkc6IFwiaGFuZGxpbmdcIixcblx0SEFORExFRDogXCJoYW5kbGVkXCIsXG5cdE5PX0hBTkRMRVI6IFwibm9oYW5kbGVyXCIsXG5cdFRSQU5TSVRJT046IFwidHJhbnNpdGlvblwiLFxuXHRUUkFOU0lUSU9ORUQ6IFwidHJhbnNpdGlvbmVkXCIsXG5cdElOVkFMSURfU1RBVEU6IFwiaW52YWxpZHN0YXRlXCIsXG5cdERFRkVSUkVEOiBcImRlZmVycmVkXCIsXG5cdE5FV19GU006IFwibmV3ZnNtXCJcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJlaGF2aW9yYWxGc20gPSByZXF1aXJlKCBcIi4vQmVoYXZpb3JhbEZzbVwiICk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4vdXRpbHNcIiApO1xudmFyIF8gPSByZXF1aXJlKCBcImxvZGFzaFwiICk7XG5cbnZhciBGc20gPSB7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRCZWhhdmlvcmFsRnNtLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLmVuc3VyZUNsaWVudE1ldGEoKTtcblx0fSxcblx0aW5pdENsaWVudDogZnVuY3Rpb24gaW5pdENsaWVudCgpIHtcblx0XHR2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5pbml0aWFsU3RhdGU7XG5cdFx0aWYgKCAhaW5pdGlhbFN0YXRlICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIllvdSBtdXN0IHNwZWNpZnkgYW4gaW5pdGlhbCBzdGF0ZSBmb3IgdGhpcyBGU01cIiApO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLnN0YXRlc1sgaW5pdGlhbFN0YXRlIF0gKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVGhlIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdGF0ZXMgb2JqZWN0LlwiICk7XG5cdFx0fVxuXHRcdHRoaXMudHJhbnNpdGlvbiggaW5pdGlhbFN0YXRlICk7XG5cdH0sXG5cdGVuc3VyZUNsaWVudE1ldGE6IGZ1bmN0aW9uIGVuc3VyZUNsaWVudE1ldGEoKSB7XG5cdFx0aWYgKCAhdGhpcy5fc3RhbXBlZCApIHtcblx0XHRcdHRoaXMuX3N0YW1wZWQgPSB0cnVlO1xuXHRcdFx0Xy5kZWZhdWx0cyggdGhpcywgXy5jbG9uZURlZXAoIHV0aWxzLmdldERlZmF1bHRDbGllbnRNZXRhKCkgKSApO1xuXHRcdFx0dGhpcy5pbml0Q2xpZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVuc3VyZUNsaWVudEFyZzogZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0dmFyIF9hcmdzID0gYXJncztcblx0XHQvLyB3ZSBuZWVkIHRvIHRlc3QgdGhlIGFyZ3MgYW5kIHZlcmlmeSB0aGF0IGlmIGEgY2xpZW50IGFyZyBoYXNcblx0XHQvLyBiZWVuIHBhc3NlZCwgaXQgbXVzdCBiZSB0aGlzIEZTTSBpbnN0YW5jZSAodGhpcyBpc24ndCBhIGJlaGF2aW9yYWwgRlNNKVxuXHRcdGlmICggdHlwZW9mIF9hcmdzWyAwIF0gPT09IFwib2JqZWN0XCIgJiYgISggXCJpbnB1dFR5cGVcIiBpbiBfYXJnc1sgMCBdICkgJiYgX2FyZ3NbIDAgXSAhPT0gdGhpcyApIHtcblx0XHRcdF9hcmdzLnNwbGljZSggMCwgMSwgdGhpcyApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBfYXJnc1sgMCBdICE9PSBcIm9iamVjdFwiIHx8ICggdHlwZW9mIF9hcmdzWyAwIF0gPT09IFwib2JqZWN0XCIgJiYgKCBcImlucHV0VHlwZVwiIGluIF9hcmdzWyAwIF0gKSApICkge1xuXHRcdFx0X2FyZ3MudW5zaGlmdCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX2FyZ3M7XG5cdH0sXG5cblx0Z2V0SGFuZGxlckFyZ3M6IGZ1bmN0aW9uKCBhcmdzLCBpc0NhdGNoQWxsICkge1xuXHRcdC8vIGluZGV4IDAgaXMgdGhlIGNsaWVudCwgaW5kZXggMSBpcyBpbnB1dFR5cGVcblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGNhdGNoLWFsbCBoYW5kbGVyLCBpbnB1dCB0eXBlIG5lZWRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBhcmdzXG5cdFx0Ly8gaW5wdXRUeXBlIG1pZ2h0IGJlIGFuIG9iamVjdCwgc28gd2UgbmVlZCB0byBqdXN0IGdldCB0aGUgaW5wdXRUeXBlIHN0cmluZyBpZiBzb1xuXHRcdHZhciBfYXJncyA9IGFyZ3M7XG5cdFx0dmFyIGlucHV0ID0gX2FyZ3NbIDEgXTtcblx0XHRpZiAoIHR5cGVvZiBpbnB1dFR5cGUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRfYXJncy5zcGxpY2UoIDEsIDEsIGlucHV0LmlucHV0VHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNDYXRjaEFsbCA/XG5cdFx0XHRfYXJncy5zbGljZSggMSApIDpcblx0XHRcdF9hcmdzLnNsaWNlKCAyICk7XG5cdH0sXG5cblx0Z2V0U3lzdGVtSGFuZGxlckFyZ3M6IGZ1bmN0aW9uKCBhcmdzLCBjbGllbnQgKSB7XG5cdFx0cmV0dXJuIGFyZ3M7XG5cdH0sXG5cblx0Ly8gXCJjbGFzc2ljXCIgbWFjaGluYSBGU00gZG8gbm90IGVtaXQgdGhlIGNsaWVudCBwcm9wZXJ0eSBvbiBldmVudHMgKHdoaWNoIHdvdWxkIGJlIHRoZSBGU00gaXRzZWxmKVxuXHRidWlsZEV2ZW50UGF5bG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSB0aGlzLmVuc3VyZUNsaWVudEFyZyggdXRpbHMuZ2V0TGVha2xlc3NBcmdzKCBhcmd1bWVudHMgKSApO1xuXHRcdHZhciBkYXRhID0gYXJnc1sgMSBdO1xuXHRcdGlmICggXy5pc1BsYWluT2JqZWN0KCBkYXRhICkgKSB7XG5cdFx0XHRyZXR1cm4gXy5leHRlbmQoIGRhdGEsIHsgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IGRhdGE6IGRhdGEgfHwgbnVsbCwgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9O1xuXHRcdH1cblx0fVxufTtcblxuXy5lYWNoKCBbXG5cdFwiaGFuZGxlXCIsXG5cdFwidHJhbnNpdGlvblwiLFxuXHRcImRlZmVyVW50aWxUcmFuc2l0aW9uXCIsXG5cdFwicHJvY2Vzc1F1ZXVlXCIsXG5cdFwiY2xlYXJRdWV1ZVwiXG5dLCBmdW5jdGlvbiggbWV0aG9kV2l0aENsaWVudEluamVjdGVkICkge1xuXHRGc21bIG1ldGhvZFdpdGhDbGllbnRJbmplY3RlZCBdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSB0aGlzLmVuc3VyZUNsaWVudEFyZyggdXRpbHMuZ2V0TGVha2xlc3NBcmdzKCBhcmd1bWVudHMgKSApO1xuXHRcdHJldHVybiBCZWhhdmlvcmFsRnNtLnByb3RvdHlwZVsgbWV0aG9kV2l0aENsaWVudEluamVjdGVkIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0fTtcbn0gKTtcblxuRnNtID0gQmVoYXZpb3JhbEZzbS5leHRlbmQoIEZzbSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZzbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0ZzbS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoIFwiLi91dGlsc1wiICk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoIFwiLi9lbWl0dGVyXCIgKTtcbnZhciB0b3BMZXZlbEVtaXR0ZXIgPSBlbWl0dGVyLmluc3RhbmNlO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoIFwiLi9ldmVudHNcIiApO1xuXG52YXIgTUFDSElOQV9QUk9QID0gXCJfX21hY2hpbmFfX1wiO1xuXG5mdW5jdGlvbiBCZWhhdmlvcmFsRnNtKCBvcHRpb25zICkge1xuXHRfLmV4dGVuZCggdGhpcywgb3B0aW9ucyApO1xuXHRfLmRlZmF1bHRzKCB0aGlzLCB1dGlscy5nZXREZWZhdWx0QmVoYXZpb3JhbE9wdGlvbnMoKSApO1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR0b3BMZXZlbEVtaXR0ZXIuZW1pdCggZXZlbnRzLk5FV19GU00sIHRoaXMgKTtcbn1cblxuXy5leHRlbmQoIEJlaGF2aW9yYWxGc20ucHJvdG90eXBlLCB7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0aW5pdENsaWVudDogZnVuY3Rpb24gaW5pdENsaWVudCggY2xpZW50ICkge1xuXHRcdHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcblx0XHRpZiAoICFpbml0aWFsU3RhdGUgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiWW91IG11c3Qgc3BlY2lmeSBhbiBpbml0aWFsIHN0YXRlIGZvciB0aGlzIEZTTVwiICk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMuc3RhdGVzWyBpbml0aWFsU3RhdGUgXSApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJUaGUgaW5pdGlhbCBzdGF0ZSBzcGVjaWZpZWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHN0YXRlcyBvYmplY3QuXCIgKTtcblx0XHR9XG5cdFx0dGhpcy50cmFuc2l0aW9uKCBjbGllbnQsIGluaXRpYWxTdGF0ZSApO1xuXHR9LFxuXG5cdGNvbmZpZ0ZvclN0YXRlOiBmdW5jdGlvbiBjb25maWdGb3JTdGF0ZSggbmV3U3RhdGUgKSB7XG5cdFx0dmFyIG5ld1N0YXRlT2JqID0gdGhpcy5zdGF0ZXNbIG5ld1N0YXRlIF07XG5cdFx0dmFyIGNoaWxkO1xuXHRcdF8uZWFjaCggdGhpcy5oaWVyYXJjaHksIGZ1bmN0aW9uKCBjaGlsZExpc3RlbmVyLCBrZXkgKSB7XG5cdFx0XHRpZiAoIGNoaWxkTGlzdGVuZXIgJiYgdHlwZW9mIGNoaWxkTGlzdGVuZXIub2ZmID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdGNoaWxkTGlzdGVuZXIub2ZmKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBuZXdTdGF0ZU9iai5fY2hpbGQgKSB7XG5cdFx0XHRuZXdTdGF0ZU9iai5fY2hpbGQgPSB1dGlscy5nZXRDaGlsZEZzbUluc3RhbmNlKCBuZXdTdGF0ZU9iai5fY2hpbGQgKTtcblx0XHRcdGNoaWxkID0gbmV3U3RhdGVPYmouX2NoaWxkICYmIG5ld1N0YXRlT2JqLl9jaGlsZC5pbnN0YW5jZTtcblx0XHRcdHRoaXMuaGllcmFyY2h5WyBjaGlsZC5uYW1lc3BhY2UgXSA9IHV0aWxzLmxpc3RlblRvQ2hpbGQoIHRoaXMsIGNoaWxkICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9LFxuXG5cdGVuc3VyZUNsaWVudE1ldGE6IGZ1bmN0aW9uIGVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBjbGllbnQgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiQW4gRlNNIGNsaWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIiApO1xuXHRcdH1cblx0XHRjbGllbnRbIE1BQ0hJTkFfUFJPUCBdID0gY2xpZW50WyBNQUNISU5BX1BST1AgXSB8fCB7fTtcblx0XHRpZiAoICFjbGllbnRbIE1BQ0hJTkFfUFJPUCBdWyB0aGlzLm5hbWVzcGFjZSBdICkge1xuXHRcdFx0Y2xpZW50WyBNQUNISU5BX1BST1AgXVsgdGhpcy5uYW1lc3BhY2UgXSA9IF8uY2xvbmVEZWVwKCB1dGlscy5nZXREZWZhdWx0Q2xpZW50TWV0YSgpICk7XG5cdFx0XHR0aGlzLmluaXRDbGllbnQoIGNsaWVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xpZW50WyBNQUNISU5BX1BST1AgXVsgdGhpcy5uYW1lc3BhY2UgXTtcblx0fSxcblxuXHRidWlsZEV2ZW50UGF5bG9hZDogZnVuY3Rpb24oIGNsaWVudCwgZGF0YSApIHtcblx0XHRpZiAoIF8uaXNQbGFpbk9iamVjdCggZGF0YSApICkge1xuXHRcdFx0cmV0dXJuIF8uZXh0ZW5kKCBkYXRhLCB7IGNsaWVudDogY2xpZW50LCBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlIH0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHsgY2xpZW50OiBjbGllbnQsIGRhdGE6IGRhdGEgfHwgbnVsbCwgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9O1xuXHRcdH1cblx0fSxcblxuXHRnZXRIYW5kbGVyQXJnczogZnVuY3Rpb24oIGFyZ3MsIGlzQ2F0Y2hBbGwgKSB7XG5cdFx0Ly8gaW5kZXggMCBpcyB0aGUgY2xpZW50LCBpbmRleCAxIGlzIGlucHV0VHlwZVxuXHRcdC8vIGlmIHdlJ3JlIGluIGEgY2F0Y2gtYWxsIGhhbmRsZXIsIGlucHV0IHR5cGUgbmVlZHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGFyZ3Ncblx0XHQvLyBpbnB1dFR5cGUgbWlnaHQgYmUgYW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGp1c3QgZ2V0IHRoZSBpbnB1dFR5cGUgc3RyaW5nIGlmIHNvXG5cdFx0dmFyIF9hcmdzID0gYXJncy5zbGljZSggMCApO1xuXHRcdHZhciBpbnB1dCA9IF9hcmdzWyAxIF07XG5cdFx0aWYgKCB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRfYXJncy5zcGxpY2UoIDEsIDEsIGlucHV0LmlucHV0VHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNDYXRjaEFsbCA/XG5cdFx0XHRfYXJncyA6XG5cdFx0XHRbIF9hcmdzWyAwIF0gXS5jb25jYXQoIF9hcmdzLnNsaWNlKCAyICkgKTtcblx0fSxcblxuXHRnZXRTeXN0ZW1IYW5kbGVyQXJnczogZnVuY3Rpb24oIGFyZ3MsIGNsaWVudCApIHtcblx0XHRyZXR1cm4gWyBjbGllbnQgXS5jb25jYXQoIGFyZ3MgKTtcblx0fSxcblxuXHRoYW5kbGU6IGZ1bmN0aW9uKCBjbGllbnQsIGlucHV0ICkge1xuXHRcdHZhciBpbnB1dERlZiA9IGlucHV0O1xuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIlRoZSBpbnB1dCBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIEZTTSdzIGhhbmRsZSBtZXRob2QgaXMgdW5kZWZpbmVkLiBEaWQgeW91IGZvcmdldCB0byBwYXNzIHRoZSBpbnB1dCBuYW1lP1wiICk7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aW5wdXREZWYgPSB7IGlucHV0VHlwZTogaW5wdXQsIGRlbGVnYXRlZDogZmFsc2UsIHRpY2tldDogdW5kZWZpbmVkIH07XG5cdFx0fVxuXHRcdHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKCBjbGllbnQgKTtcblx0XHR2YXIgYXJncyA9IHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICk7XG5cdFx0aWYgKCB0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRhcmdzLnNwbGljZSggMSwgMSwgaW5wdXREZWYgKTtcblx0XHR9XG5cdFx0Y2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJncyA9IGFyZ3Muc2xpY2UoIDEgKTtcblx0XHR2YXIgY3VycmVudFN0YXRlID0gY2xpZW50TWV0YS5zdGF0ZTtcblx0XHR2YXIgc3RhdGVPYmogPSB0aGlzLnN0YXRlc1sgY3VycmVudFN0YXRlIF07XG5cdFx0dmFyIGhhbmRsZXJOYW1lO1xuXHRcdHZhciBoYW5kbGVyO1xuXHRcdHZhciBpc0NhdGNoQWxsID0gZmFsc2U7XG5cdFx0dmFyIGNoaWxkO1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0dmFyIGFjdGlvbjtcblx0XHRpZiAoICFjbGllbnRNZXRhLmluRXhpdEhhbmRsZXIgKSB7XG5cdFx0XHRjaGlsZCA9IHRoaXMuY29uZmlnRm9yU3RhdGUoIGN1cnJlbnRTdGF0ZSApO1xuXHRcdFx0aWYgKCBjaGlsZCAmJiAhdGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbIGlucHV0RGVmLnRpY2tldCBdICYmICFpbnB1dERlZi5idWJibGluZyApIHtcblx0XHRcdFx0aW5wdXREZWYudGlja2V0ID0gKCBpbnB1dERlZi50aWNrZXQgfHwgdXRpbHMuY3JlYXRlVVVJRCgpICk7XG5cdFx0XHRcdGlucHV0RGVmLmRlbGVnYXRlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMucGVuZGluZ0RlbGVnYXRpb25zWyBpbnB1dERlZi50aWNrZXQgXSA9IHsgZGVsZWdhdGVkVG86IGNoaWxkLm5hbWVzcGFjZSB9O1xuXHRcdFx0XHQvLyBXQVJOSU5HIC0gcmV0dXJuaW5nIGEgdmFsdWUgZnJvbSBgaGFuZGxlYCBvbiBjaGlsZCBGU01zIGlzIG5vdCByZWFsbHkgc3VwcG9ydGVkLlxuXHRcdFx0XHQvLyBJZiB5b3UgbmVlZCB0byByZXR1cm4gdmFsdWVzIGZyb20gY2hpbGQgRlNNIGlucHV0IGhhbmRsZXJzLCB1c2UgZXZlbnRzIGluc3RlYWQuXG5cdFx0XHRcdHJlc3VsdCA9IGNoaWxkLmhhbmRsZS5hcHBseSggY2hpbGQsIGFyZ3MgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggaW5wdXREZWYudGlja2V0ICYmIHRoaXMucGVuZGluZ0RlbGVnYXRpb25zWyBpbnB1dERlZi50aWNrZXQgXSApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbIGlucHV0RGVmLnRpY2tldCBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhbmRsZXJOYW1lID0gc3RhdGVPYmpbIGlucHV0RGVmLmlucHV0VHlwZSBdID8gaW5wdXREZWYuaW5wdXRUeXBlIDogXCIqXCI7XG5cdFx0XHRcdGlzQ2F0Y2hBbGwgPSAoIGhhbmRsZXJOYW1lID09PSBcIipcIiApO1xuXHRcdFx0XHRoYW5kbGVyID0gKCBzdGF0ZU9ialsgaGFuZGxlck5hbWUgXSB8fCB0aGlzWyBoYW5kbGVyTmFtZSBdICkgfHwgdGhpc1sgXCIqXCIgXTtcblx0XHRcdFx0YWN0aW9uID0gY2xpZW50TWV0YS5zdGF0ZSArIFwiLlwiICsgaGFuZGxlck5hbWU7XG5cdFx0XHRcdGNsaWVudE1ldGEuY3VycmVudEFjdGlvbiA9IGFjdGlvbjtcblx0XHRcdFx0dmFyIGV2ZW50UGF5bG9hZCA9IHRoaXMuYnVpbGRFdmVudFBheWxvYWQoXG5cdFx0XHRcdFx0Y2xpZW50LFxuXHRcdFx0XHRcdHsgaW5wdXRUeXBlOiBpbnB1dERlZi5pbnB1dFR5cGUsIGRlbGVnYXRlZDogaW5wdXREZWYuZGVsZWdhdGVkLCB0aWNrZXQ6IGlucHV0RGVmLnRpY2tldCB9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmICggIWhhbmRsZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCBldmVudHMuTk9fSEFORExFUiwgXy5leHRlbmQoIHsgYXJnczogYXJncyB9LCBldmVudFBheWxvYWQgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZW1pdCggZXZlbnRzLkhBTkRMSU5HLCBldmVudFBheWxvYWQgKTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBoYW5kbGVyLmFwcGx5KCB0aGlzLCB0aGlzLmdldEhhbmRsZXJBcmdzKCBhcmdzLCBpc0NhdGNoQWxsICkgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gaGFuZGxlcjtcblx0XHRcdFx0XHRcdHRoaXMudHJhbnNpdGlvbiggY2xpZW50LCBoYW5kbGVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZW1pdCggZXZlbnRzLkhBTkRMRUQsIGV2ZW50UGF5bG9hZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsaWVudE1ldGEucHJpb3JBY3Rpb24gPSBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb247XG5cdFx0XHRcdGNsaWVudE1ldGEuY3VycmVudEFjdGlvbiA9IFwiXCI7XG5cdFx0XHRcdGNsaWVudE1ldGEuY3VycmVudEFjdGlvbkFyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oIGNsaWVudCwgbmV3U3RhdGUgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdHZhciBjdXJTdGF0ZSA9IGNsaWVudE1ldGEuc3RhdGU7XG5cdFx0dmFyIGN1clN0YXRlT2JqID0gdGhpcy5zdGF0ZXNbIGN1clN0YXRlIF07XG5cdFx0dmFyIG5ld1N0YXRlT2JqID0gdGhpcy5zdGF0ZXNbIG5ld1N0YXRlIF07XG5cdFx0dmFyIGNoaWxkO1xuXHRcdHZhciBhcmdzID0gdXRpbHMuZ2V0TGVha2xlc3NBcmdzKCBhcmd1bWVudHMgKS5zbGljZSggMiApO1xuXHRcdGlmICggIWNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciAmJiBuZXdTdGF0ZSAhPT0gY3VyU3RhdGUgKSB7XG5cdFx0XHRpZiAoIG5ld1N0YXRlT2JqICkge1xuXHRcdFx0XHRjaGlsZCA9IHRoaXMuY29uZmlnRm9yU3RhdGUoIG5ld1N0YXRlICk7XG5cdFx0XHRcdGlmICggY3VyU3RhdGVPYmogJiYgY3VyU3RhdGVPYmouX29uRXhpdCApIHtcblx0XHRcdFx0XHRjbGllbnRNZXRhLmluRXhpdEhhbmRsZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGN1clN0YXRlT2JqLl9vbkV4aXQuY2FsbCggdGhpcywgY2xpZW50ICk7XG5cdFx0XHRcdFx0Y2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xpZW50TWV0YS50YXJnZXRSZXBsYXlTdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHRjbGllbnRNZXRhLnByaW9yU3RhdGUgPSBjdXJTdGF0ZTtcblx0XHRcdFx0Y2xpZW50TWV0YS5zdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHR2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5idWlsZEV2ZW50UGF5bG9hZCggY2xpZW50LCB7XG5cdFx0XHRcdFx0ZnJvbVN0YXRlOiBjbGllbnRNZXRhLnByaW9yU3RhdGUsXG5cdFx0XHRcdFx0YWN0aW9uOiBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb24sXG5cdFx0XHRcdFx0dG9TdGF0ZTogbmV3U3RhdGVcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5UUkFOU0lUSU9OLCBldmVudFBheWxvYWQgKTtcblx0XHRcdFx0aWYgKCBuZXdTdGF0ZU9iai5fb25FbnRlciApIHtcblx0XHRcdFx0XHRuZXdTdGF0ZU9iai5fb25FbnRlci5hcHBseSggdGhpcywgdGhpcy5nZXRTeXN0ZW1IYW5kbGVyQXJncyggYXJncywgY2xpZW50ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5UUkFOU0lUSU9ORUQsIGV2ZW50UGF5bG9hZCApO1xuXHRcdFx0XHRpZiAoIGNoaWxkICkge1xuXHRcdFx0XHRcdGNoaWxkLmhhbmRsZSggY2xpZW50LCBcIl9yZXNldFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNsaWVudE1ldGEudGFyZ2V0UmVwbGF5U3RhdGUgPT09IG5ld1N0YXRlICkge1xuXHRcdFx0XHRcdHRoaXMucHJvY2Vzc1F1ZXVlKCBjbGllbnQsIGV2ZW50cy5ORVhUX1RSQU5TSVRJT04gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5JTlZBTElEX1NUQVRFLCB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKCBjbGllbnQsIHtcblx0XHRcdFx0c3RhdGU6IGNsaWVudE1ldGEuc3RhdGUsXG5cdFx0XHRcdGF0dGVtcHRlZFN0YXRlOiBuZXdTdGF0ZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRlZmVyVW50aWxUcmFuc2l0aW9uOiBmdW5jdGlvbiggY2xpZW50LCBzdGF0ZU5hbWUgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdGlmICggY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJncyApIHtcblx0XHRcdHZhciBxdWV1ZWQgPSB7XG5cdFx0XHRcdHR5cGU6IGV2ZW50cy5ORVhUX1RSQU5TSVRJT04sXG5cdFx0XHRcdHVudGlsU3RhdGU6IHN0YXRlTmFtZSxcblx0XHRcdFx0YXJnczogY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJnc1xuXHRcdFx0fTtcblx0XHRcdGNsaWVudE1ldGEuaW5wdXRRdWV1ZS5wdXNoKCBxdWV1ZWQgKTtcblx0XHRcdHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKCBjbGllbnQsIHtcblx0XHRcdFx0c3RhdGU6IGNsaWVudE1ldGEuc3RhdGUsXG5cdFx0XHRcdHF1ZXVlZEFyZ3M6IHF1ZXVlZFxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5lbWl0KCBldmVudHMuREVGRVJSRUQsIGV2ZW50UGF5bG9hZCApO1xuXHRcdH1cblx0fSxcblxuXHRkZWZlckFuZFRyYW5zaXRpb246IGZ1bmN0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApIHtcblx0XHR0aGlzLmRlZmVyVW50aWxUcmFuc2l0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApO1xuXHRcdHRoaXMudHJhbnNpdGlvbiggY2xpZW50LCBzdGF0ZU5hbWUgKTtcblx0fSxcblxuXHRwcm9jZXNzUXVldWU6IGZ1bmN0aW9uKCBjbGllbnQgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdHZhciBmaWx0ZXJGbiA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuICggKCAhaXRlbS51bnRpbFN0YXRlICkgfHwgKCBpdGVtLnVudGlsU3RhdGUgPT09IGNsaWVudE1ldGEuc3RhdGUgKSApO1xuXHRcdH07XG5cdFx0dmFyIHRvUHJvY2VzcyA9IF8uZmlsdGVyKCBjbGllbnRNZXRhLmlucHV0UXVldWUsIGZpbHRlckZuICk7XG5cdFx0Y2xpZW50TWV0YS5pbnB1dFF1ZXVlID0gXy5kaWZmZXJlbmNlKCBjbGllbnRNZXRhLmlucHV0UXVldWUsIHRvUHJvY2VzcyApO1xuXHRcdF8uZWFjaCggdG9Qcm9jZXNzLCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdHRoaXMuaGFuZGxlLmFwcGx5KCB0aGlzLCBbIGNsaWVudCBdLmNvbmNhdCggaXRlbS5hcmdzICkgKTtcblx0XHR9LmJpbmQoIHRoaXMgKSApO1xuXHR9LFxuXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCBjbGllbnQsIG5hbWUgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRjbGllbnRNZXRhLmlucHV0UXVldWUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGZpbHRlciA9IGZ1bmN0aW9uKCBldm50ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBuYW1lID8gZXZudC51bnRpbFN0YXRlICE9PSBuYW1lIDogdHJ1ZSApO1xuXHRcdFx0fTtcblx0XHRcdGNsaWVudE1ldGEuaW5wdXRRdWV1ZSA9IF8uZmlsdGVyKCBjbGllbnRNZXRhLmlucHV0UXVldWUsIGZpbHRlciApO1xuXHRcdH1cblx0fSxcblxuXHRjb21wb3NpdGVTdGF0ZTogZnVuY3Rpb24oIGNsaWVudCApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0dmFyIHN0YXRlID0gY2xpZW50TWV0YS5zdGF0ZTtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLnN0YXRlc1tzdGF0ZV0uX2NoaWxkICYmIHRoaXMuc3RhdGVzW3N0YXRlXS5fY2hpbGQuaW5zdGFuY2U7XG5cdFx0aWYgKCBjaGlsZCApIHtcblx0XHRcdHN0YXRlICs9IFwiLlwiICsgY2hpbGQuY29tcG9zaXRlU3RhdGUoIGNsaWVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn0sIGVtaXR0ZXIuZ2V0SW5zdGFuY2UoKSApO1xuXG5CZWhhdmlvcmFsRnNtLmV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcmFsRnNtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQmVoYXZpb3JhbEZzbS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap acca941d5a487012791a","var _ = require( \"lodash\" );\nvar emitter = require( \"./emitter\" );\n\nmodule.exports = _.merge( emitter.instance, {\n\tFsm: require( \"./Fsm\" ),\n\tBehavioralFsm: require( \"./BehavioralFsm\" ),\n\tutils: require( \"./utils\" ),\n\teventListeners: {\n\t\tnewFsm: []\n\t}\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/machina.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n// module id = 1\n// module chunks = 0","var utils = require( \"./utils\" );\nvar _ = require( \"lodash\" );\n\nfunction getInstance() {\n\treturn {\n\t\temit: function( eventName ) {\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}\n\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}\n\t\t},\n\n\t\ton: function( eventName, callback ) {\n\t\t\tvar self = this;\n\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t}\n\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\treturn {\n\t\t\t\teventName: eventName,\n\t\t\t\tcallback: callback,\n\t\t\t\toff: function() {\n\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\toff: function( eventName, callback ) {\n\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\tif ( !eventName ) {\n\t\t\t\tthis.eventListeners = {};\n\t\t\t} else {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t} else {\n\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tgetInstance: getInstance,\n\tinstance: getInstance()\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/emitter.js\n// module id = 2\n// module chunks = 0","var slice = [].slice;\nvar events = require( \"./events.js\" );\nvar _ = require( \"lodash\" );\n\nvar makeFsmNamespace = ( function() {\n\tvar machinaCount = 0;\n\treturn function() {\n\t\treturn \"fsm.\" + machinaCount++;\n\t};\n} )();\n\nfunction getDefaultBehavioralOptions() {\n\treturn {\n\t\tinitialState: \"uninitialized\",\n\t\teventListeners: {\n\t\t\t\"*\": []\n\t\t},\n\t\tstates: {},\n\t\tnamespace: makeFsmNamespace(),\n\t\tuseSafeEmit: false,\n\t\thierarchy: {},\n\t\tpendingDelegations: {}\n\t};\n}\n\nfunction getDefaultClientMeta() {\n\treturn {\n\t\tinputQueue: [],\n\t\ttargetReplayState: \"\",\n\t\tstate: undefined,\n\t\tpriorState: undefined,\n\t\tpriorAction: \"\",\n\t\tcurrentAction: \"\",\n\t\tcurrentActionArgs: undefined,\n\t\tinExitHandler: false\n\t};\n}\n\nfunction getLeaklessArgs( args, startIdx ) {\n\tvar result = [];\n\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\tresult[ i ] = args[ i ];\n\t}\n\treturn result;\n}\n/*\n\thandle ->\n\t\tchild = stateObj._child && stateObj._child.instance;\n\n\ttransition ->\n\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\tchild = newStateObj._child && newStateObj._child.instance;\n*/\nfunction getChildFsmInstance( config ) {\n\tif ( !config ) {\n\t\treturn;\n\t}\n\tvar childFsmDefinition = {};\n\tif ( typeof config === \"object\" ) {\n\t\t// is this a config object with a factory?\n\t\tif ( config.factory ) {\n\t\t\tchildFsmDefinition = config;\n\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t} else {\n\t\t\t// assuming this is a machina instance\n\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\treturn config;\n\t\t\t};\n\t\t}\n\t} else if ( typeof config === \"function\" ) {\n\t\tchildFsmDefinition.factory = config;\n\t}\n\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\treturn childFsmDefinition;\n}\n\nfunction listenToChild( fsm, child ) {\n\t// Need to investigate potential for discarded event\n\t// listener memory leak in long-running, deeply-nested hierarchies.\n\treturn child.on( \"*\", function( eventName, data ) {\n\t\tswitch ( eventName ) {\n\t\t\tcase events.NO_HANDLER:\n\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t}\n\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase events.HANDLING :\n\t\t\t\tvar ticket = data.ticket;\n\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t}\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t}\n\t} );\n}\n\n// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n// that share the same extended prototype won't share state *on* those prototypes.\nvar _machKeys = [ \"states\", \"initialState\" ];\nvar extend = function( protoProps, staticProps ) {\n\tvar parent = this;\n\tvar fsm; // placeholder for instance constructor\n\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\n\t// The constructor function for the new subclass is either defined by you\n\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t// by us to simply call the parent's constructor.\n\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\tfsm = protoProps.constructor;\n\t} else {\n\t\t// The default machina constructor (when using inheritance) creates a\n\t\t// deep copy of the states/initialState values from the prototype and\n\t\t// extends them over the instance so that they'll be instance-level.\n\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t// value will be preferred over any data pulled up from the prototype.\n\t\tfsm = function() {\n\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\tvar blendedState;\n\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\tparent.apply( this, args );\n\t\t};\n\t}\n\n\t// Inherit class (static) properties from parent.\n\t_.merge( fsm, parent );\n\n\t// Set the prototype chain to inherit from `parent`, without calling\n\t// `parent`'s constructor function.\n\tCtor.prototype = parent.prototype;\n\tfsm.prototype = new Ctor();\n\n\t// Add prototype properties (instance properties) to the subclass,\n\t// if supplied.\n\tif ( protoProps ) {\n\t\t_.extend( fsm.prototype, protoProps );\n\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\taccum[ key ] = val;\n\t\t\t}\n\t\t} ) );\n\t}\n\n\t// Add static properties to the constructor function, if supplied.\n\tif ( staticProps ) {\n\t\t_.merge( fsm, staticProps );\n\t}\n\n\t// Correctly set child's `prototype.constructor`.\n\tfsm.prototype.constructor = fsm;\n\n\t// Set a convenience property in case the parent's prototype is needed later.\n\tfsm.__super__ = parent.prototype;\n\treturn fsm;\n};\n\nfunction createUUID() {\n\tvar s = [];\n\tvar hexDigits = \"0123456789abcdef\";\n\tfor ( var i = 0; i < 36; i++ ) {\n\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t}\n\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t/* jshint ignore:start */\n\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t/* jshint ignore:end */\n\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\treturn s.join( \"\" );\n}\n\nmodule.exports = {\n\tcreateUUID: createUUID,\n\textend: extend,\n\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\tgetDefaultOptions: getDefaultBehavioralOptions,\n\tgetDefaultClientMeta: getDefaultClientMeta,\n\tgetChildFsmInstance: getChildFsmInstance,\n\tgetLeaklessArgs: getLeaklessArgs,\n\tlistenToChild: listenToChild,\n\tmakeFsmNamespace: makeFsmNamespace\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 3\n// module chunks = 0","module.exports = {\n\tNEXT_TRANSITION: \"transition\",\n\tHANDLING: \"handling\",\n\tHANDLED: \"handled\",\n\tNO_HANDLER: \"nohandler\",\n\tTRANSITION: \"transition\",\n\tTRANSITIONED: \"transitioned\",\n\tINVALID_STATE: \"invalidstate\",\n\tDEFERRED: \"deferred\",\n\tNEW_FSM: \"newfsm\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/events.js\n// module id = 4\n// module chunks = 0","var BehavioralFsm = require( \"./BehavioralFsm\" );\nvar utils = require( \"./utils\" );\nvar _ = require( \"lodash\" );\n\nvar Fsm = {\n\tconstructor: function() {\n\t\tBehavioralFsm.apply( this, arguments );\n\t\tthis.ensureClientMeta();\n\t},\n\tinitClient: function initClient() {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( initialState );\n\t},\n\tensureClientMeta: function ensureClientMeta() {\n\t\tif ( !this._stamped ) {\n\t\t\tthis._stamped = true;\n\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\tthis.initClient();\n\t\t}\n\t\treturn this;\n\t},\n\n\tensureClientArg: function( args ) {\n\t\tvar _args = args;\n\t\t// we need to test the args and verify that if a client arg has\n\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t_args.splice( 0, 1, this );\n\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t_args.unshift( this );\n\t\t}\n\t\treturn _args;\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args;\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args.slice( 1 ) :\n\t\t\t_args.slice( 2 );\n\t},\n\n\tgetSystemHandlerArgs: function( args, client ) {\n\t\treturn args;\n\t},\n\n\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\tbuildEventPayload: function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\tvar data = args[ 1 ];\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t}\n\t}\n};\n\n_.each( [\n\t\"handle\",\n\t\"transition\",\n\t\"deferUntilTransition\",\n\t\"processQueue\",\n\t\"clearQueue\"\n], function( methodWithClientInjected ) {\n\tFsm[ methodWithClientInjected ] = function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t};\n} );\n\nFsm = BehavioralFsm.extend( Fsm );\n\nmodule.exports = Fsm;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Fsm.js\n// module id = 5\n// module chunks = 0","var _ = require( \"lodash\" );\nvar utils = require( \"./utils\" );\nvar emitter = require( \"./emitter\" );\nvar topLevelEmitter = emitter.instance;\nvar events = require( \"./events\" );\n\nvar MACHINA_PROP = \"__machina__\";\n\nfunction BehavioralFsm( options ) {\n\t_.extend( this, options );\n\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\tthis.initialize.apply( this, arguments );\n\ttopLevelEmitter.emit( events.NEW_FSM, this );\n}\n\n_.extend( BehavioralFsm.prototype, {\n\tinitialize: function() {},\n\n\tinitClient: function initClient( client ) {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( client, initialState );\n\t},\n\n\tconfigForState: function configForState( newState ) {\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\tchildListener.off();\n\t\t\t}\n\t\t} );\n\n\t\tif ( newStateObj._child ) {\n\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t}\n\n\t\treturn child;\n\t},\n\n\tensureClientMeta: function ensureClientMeta( client ) {\n\t\tif ( typeof client !== \"object\" ) {\n\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t}\n\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\tthis.initClient( client );\n\t\t}\n\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t},\n\n\tbuildEventPayload: function( client, data ) {\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t}\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args.slice( 0 );\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof input === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args :\n\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t},\n\n\tgetSystemHandlerArgs: function( args, client ) {\n\t\treturn [ client ].concat( args );\n\t},\n\n\thandle: function( client, input ) {\n\t\tvar inputDef = input;\n\t\tif ( typeof input === \"undefined\" ) {\n\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t}\n\t\tif ( typeof input === \"string\" ) {\n\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t}\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\tif ( typeof input !== \"object\" ) {\n\t\t\targs.splice( 1, 1, inputDef );\n\t\t}\n\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\tvar currentState = clientMeta.state;\n\t\tvar stateObj = this.states[ currentState ];\n\t\tvar handlerName;\n\t\tvar handler;\n\t\tvar isCatchAll = false;\n\t\tvar child;\n\t\tvar result;\n\t\tvar action;\n\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\tchild = this.configForState( currentState );\n\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\tinputDef.delegated = true;\n\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t} else {\n\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t}\n\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\tclient,\n\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t);\n\t\t\t\tif ( !handler ) {\n\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t}\n\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t\tclientMeta.currentActionArgs = undefined;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\ttransition: function( client, newState ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar curState = clientMeta.state;\n\t\tvar curStateObj = this.states[ curState ];\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\tvar args = utils.getLeaklessArgs( arguments ).slice( 2 );\n\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\tif ( newStateObj ) {\n\t\t\t\tchild = this.configForState( newState );\n\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t}\n\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\tclientMeta.state = newState;\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\ttoState: newState\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\tnewStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );\n\t\t\t\t}\n\t\t\t\tthis.emit( events.TRANSITIONED, eventPayload );\n\t\t\t\tif ( child ) {\n\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t}\n\n\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tattemptedState: newState\n\t\t\t} ) );\n\t\t}\n\t},\n\n\tdeferUntilTransition: function( client, stateName ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\tvar queued = {\n\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\tuntilState: stateName,\n\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t};\n\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tqueuedArgs: queued\n\t\t\t} );\n\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t}\n\t},\n\n\tdeferAndTransition: function( client, stateName ) {\n\t\tthis.deferUntilTransition( client, stateName );\n\t\tthis.transition( client, stateName );\n\t},\n\n\tprocessQueue: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar filterFn = function( item ) {\n\t\t\treturn ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );\n\t\t};\n\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t_.each( toProcess, function( item ) {\n\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t}.bind( this ) );\n\t},\n\n\tclearQueue: function( client, name ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tif ( !name ) {\n\t\t\tclientMeta.inputQueue = [];\n\t\t} else {\n\t\t\tvar filter = function( evnt ) {\n\t\t\t\treturn ( name ? evnt.untilState !== name : true );\n\t\t\t};\n\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t}\n\t},\n\n\tcompositeState: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar state = clientMeta.state;\n\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\tif ( child ) {\n\t\t\tstate += \".\" + child.compositeState( client );\n\t\t}\n\t\treturn state;\n\t}\n}, emitter.getInstance() );\n\nBehavioralFsm.extend = utils.extend;\n\nmodule.exports = BehavioralFsm;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/BehavioralFsm.js\n// module id = 6\n// module chunks = 0"]}