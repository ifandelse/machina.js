{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","machina.js","webpack:/webpack/bootstrap dbcf2491954d02cd6037","webpack:///src/machina.js","webpack:/external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///src/emitter.js","webpack:///src/utils.js","webpack:///src/events.js","webpack:///src/Fsm.js","webpack:///src/BehavioralFsm.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_","emitter","merge","instance","Fsm","BehavioralFsm","utils","eventListeners","newFsm","getInstance","emit","eventName","args","getLeaklessArgs","arguments","each","callback","useSafeEmit","apply","exception","console","log","stack","bind","slice","on","self","*","push","off","without","getDefaultBehavioralOptions","initialState","states","namespace","makeFsmNamespace","hierarchy","pendingDelegations","getDefaultClientMeta","inputQueue","targetReplayState","state","undefined","priorState","priorAction","currentAction","currentActionArgs","inExitHandler","startIdx","result","i","length","getChildFsmInstance","config","childFsmDefinition","listenToChild","fsm","child","data","events","NO_HANDLER","ticket","delegated","bubbling","inputType","handle","HANDLING","createUUID","s","hexDigits","substr","Math","floor","random","join","machinaCount","_machKeys","extend","protoProps","staticProps","parent","machObj","Ctor","hasOwnProperty","constructor","blendedState","instanceStates","cloneDeep","prototype","transform","accum","val","key","indexOf","__super__","getDefaultOptions","NEXT_TRANSITION","HANDLED","TRANSITION","TRANSITIONED","INVALID_STATE","DEFERRED","NEW_FSM","ensureClientMeta","initClient","Error","transition","_stamped","defaults","ensureClientArg","_args","unshift","splice","getHandlerArgs","isCatchAll","input","getSystemHandlerArgs","client","buildEventPayload","isPlainObject","methodWithClientInjected","options","initialize","topLevelEmitter","MACHINA_PROP","configForState","newState","newStateObj","childListener","_child","concat","inputDef","clientMeta","handlerName","handler","action","currentState","stateObj","eventPayload","delegatedTo","curState","curStateObj","_onExit","fromState","toState","_onEnter","processQueue","attemptedState","deferUntilTransition","stateName","stateList","isArray","queued","type","untilState","queuedArgs","deferAndTransition","filterFn","item","includes","toProcess","filter","difference","clearQueue","name","evnt","compositeState"],"mappings":"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","file":"machina.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n *  * machina - A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.\n *  * Author: Jim Cowart (http://ifandelse.com)\n *  * Version: v4.0.2\n *  * Url: http://machina-js.org/\n *  * License(s): \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar emitter = __webpack_require__( 2 );\n\t\n\tmodule.exports = _.merge( emitter.instance, {\n\t\tFsm: __webpack_require__( 5 ),\n\t\tBehavioralFsm: __webpack_require__( 6 ),\n\t\tutils: __webpack_require__( 3 ),\n\t\teventListeners: {\n\t\t\tnewFsm: []\n\t\t}\n\t} );\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar utils = __webpack_require__( 3 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tfunction getInstance() {\n\t\treturn {\n\t\t\temit: function( eventName ) {\n\t\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind( this ) );\n\t\t\t\t}\n\t\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind( this ) );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ton: function( eventName, callback ) {\n\t\t\t\tvar self = this;\n\t\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\t\treturn {\n\t\t\t\t\teventName: eventName,\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\toff: function() {\n\t\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\toff: function( eventName, callback ) {\n\t\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !eventName ) {\n\t\t\t\t\tthis.eventListeners = {};\n\t\t\t\t} else {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tmodule.exports = {\n\t\tgetInstance: getInstance,\n\t\tinstance: getInstance()\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar slice = [].slice;\n\tvar events = __webpack_require__( 4 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar makeFsmNamespace = ( function() {\n\t\tvar machinaCount = 0;\n\t\treturn function() {\n\t\t\treturn \"fsm.\" + machinaCount++;\n\t\t};\n\t} )();\n\t\n\tfunction getDefaultBehavioralOptions() {\n\t\treturn {\n\t\t\tinitialState: \"uninitialized\",\n\t\t\teventListeners: {\n\t\t\t\t\"*\": []\n\t\t\t},\n\t\t\tstates: {},\n\t\t\tnamespace: makeFsmNamespace(),\n\t\t\tuseSafeEmit: false,\n\t\t\thierarchy: {},\n\t\t\tpendingDelegations: {}\n\t\t};\n\t}\n\t\n\tfunction getDefaultClientMeta() {\n\t\treturn {\n\t\t\tinputQueue: [],\n\t\t\ttargetReplayState: \"\",\n\t\t\tstate: undefined,\n\t\t\tpriorState: undefined,\n\t\t\tpriorAction: \"\",\n\t\t\tcurrentAction: \"\",\n\t\t\tcurrentActionArgs: undefined,\n\t\t\tinExitHandler: false\n\t\t};\n\t}\n\t\n\tfunction getLeaklessArgs( args, startIdx ) {\n\t\tvar result = [];\n\t\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\t\tresult[ i ] = args[ i ];\n\t\t}\n\t\treturn result;\n\t}\n\t/*\n\t\thandle ->\n\t\t\tchild = stateObj._child && stateObj._child.instance;\n\t\n\t\ttransition ->\n\t\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t*/\n\tfunction getChildFsmInstance( config ) {\n\t\tif ( !config ) {\n\t\t\treturn;\n\t\t}\n\t\tvar childFsmDefinition = {};\n\t\tif ( typeof config === \"object\" ) {\n\t\t\t// is this a config object with a factory?\n\t\t\tif ( config.factory ) {\n\t\t\t\tchildFsmDefinition = config;\n\t\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t\t} else {\n\t\t\t\t// assuming this is a machina instance\n\t\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\t\treturn config;\n\t\t\t\t};\n\t\t\t}\n\t\t} else if ( typeof config === \"function\" ) {\n\t\t\tchildFsmDefinition.factory = config;\n\t\t}\n\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\treturn childFsmDefinition;\n\t}\n\t\n\tfunction listenToChild( fsm, child ) {\n\t\t// Need to investigate potential for discarded event\n\t\t// listener memory leak in long-running, deeply-nested hierarchies.\n\t\treturn child.on( \"*\", function( eventName, data ) {\n\t\t\tswitch ( eventName ) {\n\t\t\t\tcase events.NO_HANDLER:\n\t\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t\t}\n\t\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase events.HANDLING :\n\t\t\t\t\tvar ticket = data.ticket;\n\t\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t\t}\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\t}\n\t\n\t// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n\t// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n\t// that share the same extended prototype won't share state *on* those prototypes.\n\tvar _machKeys = [ \"states\", \"initialState\" ];\n\tvar extend = function( protoProps, staticProps ) {\n\t\tvar parent = this;\n\t\tvar fsm; // placeholder for instance constructor\n\t\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\t\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\t\n\t\t// The constructor function for the new subclass is either defined by you\n\t\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t\t// by us to simply call the parent's constructor.\n\t\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\t\tfsm = protoProps.constructor;\n\t\t} else {\n\t\t\t// The default machina constructor (when using inheritance) creates a\n\t\t\t// deep copy of the states/initialState values from the prototype and\n\t\t\t// extends them over the instance so that they'll be instance-level.\n\t\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t\t// value will be preferred over any data pulled up from the prototype.\n\t\t\tfsm = function() {\n\t\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\t\tvar blendedState;\n\t\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\t\tparent.apply( this, args );\n\t\t\t};\n\t\t}\n\t\n\t\t// Inherit class (static) properties from parent.\n\t\t_.merge( fsm, parent );\n\t\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tCtor.prototype = parent.prototype;\n\t\tfsm.prototype = new Ctor();\n\t\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif ( protoProps ) {\n\t\t\t_.extend( fsm.prototype, protoProps );\n\t\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\t\taccum[ key ] = val;\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\t\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif ( staticProps ) {\n\t\t\t_.merge( fsm, staticProps );\n\t\t}\n\t\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tfsm.prototype.constructor = fsm;\n\t\n\t\t// Set a convenience property in case the parent's prototype is needed later.\n\t\tfsm.__super__ = parent.prototype;\n\t\treturn fsm;\n\t};\n\t\n\tfunction createUUID() {\n\t\tvar s = [];\n\t\tvar hexDigits = \"0123456789abcdef\";\n\t\tfor ( var i = 0; i < 36; i++ ) {\n\t\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t\t}\n\t\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t\t/* jshint ignore:start */\n\t\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t\t/* jshint ignore:end */\n\t\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\t\treturn s.join( \"\" );\n\t}\n\t\n\tmodule.exports = {\n\t\tcreateUUID: createUUID,\n\t\textend: extend,\n\t\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultClientMeta: getDefaultClientMeta,\n\t\tgetChildFsmInstance: getChildFsmInstance,\n\t\tgetLeaklessArgs: getLeaklessArgs,\n\t\tlistenToChild: listenToChild,\n\t\tmakeFsmNamespace: makeFsmNamespace\n\t};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\tNEXT_TRANSITION: \"transition\",\n\t\tHANDLING: \"handling\",\n\t\tHANDLED: \"handled\",\n\t\tNO_HANDLER: \"nohandler\",\n\t\tTRANSITION: \"transition\",\n\t\tTRANSITIONED: \"transitioned\",\n\t\tINVALID_STATE: \"invalidstate\",\n\t\tDEFERRED: \"deferred\",\n\t\tNEW_FSM: \"newfsm\"\n\t};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BehavioralFsm = __webpack_require__( 6 );\n\tvar utils = __webpack_require__( 3 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar Fsm = {\n\t\tconstructor: function() {\n\t\t\tBehavioralFsm.apply( this, arguments );\n\t\t\tthis.ensureClientMeta();\n\t\t},\n\t\tinitClient: function initClient() {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( initialState );\n\t\t},\n\t\tensureClientMeta: function ensureClientMeta() {\n\t\t\tif ( !this._stamped ) {\n\t\t\t\tthis._stamped = true;\n\t\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\t\tthis.initClient();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\tensureClientArg: function( args ) {\n\t\t\tvar _args = args;\n\t\t\t// we need to test the args and verify that if a client arg has\n\t\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t\t_args.splice( 0, 1, this );\n\t\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t\t_args.unshift( this );\n\t\t\t}\n\t\t\treturn _args;\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args;\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args.slice( 1 ) :\n\t\t\t\t_args.slice( 2 );\n\t\t},\n\t\n\t\tgetSystemHandlerArgs: function( args, client ) {\n\t\t\treturn args;\n\t\t},\n\t\n\t\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\t\tbuildEventPayload: function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\tvar data = args[ 1 ];\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_.each( [\n\t\t\"handle\",\n\t\t\"transition\",\n\t\t\"deferUntilTransition\",\n\t\t\"processQueue\",\n\t\t\"clearQueue\"\n\t], function( methodWithClientInjected ) {\n\t\tFsm[ methodWithClientInjected ] = function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t\t};\n\t} );\n\t\n\tFsm = BehavioralFsm.extend( Fsm );\n\t\n\tmodule.exports = Fsm;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar utils = __webpack_require__( 3 );\n\tvar emitter = __webpack_require__( 2 );\n\tvar topLevelEmitter = emitter.instance;\n\tvar events = __webpack_require__( 4 );\n\t\n\tvar MACHINA_PROP = \"__machina__\";\n\t\n\tfunction BehavioralFsm( options ) {\n\t\t_.extend( this, options );\n\t\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\t\tthis.initialize.apply( this, arguments );\n\t\ttopLevelEmitter.emit( events.NEW_FSM, this );\n\t}\n\t\n\t_.extend( BehavioralFsm.prototype, {\n\t\tinitialize: function() {},\n\t\n\t\tinitClient: function initClient( client ) {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( client, initialState );\n\t\t},\n\t\n\t\tconfigForState: function configForState( newState ) {\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\t\tchildListener.off();\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tif ( newStateObj._child ) {\n\t\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t\t}\n\t\n\t\t\treturn child;\n\t\t},\n\t\n\t\tensureClientMeta: function ensureClientMeta( client ) {\n\t\t\tif ( typeof client !== \"object\" ) {\n\t\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t\t}\n\t\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\t\tthis.initClient( client );\n\t\t\t}\n\t\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t\t},\n\t\n\t\tbuildEventPayload: function( client, data ) {\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args.slice( 0 );\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof input === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args :\n\t\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t\t},\n\t\n\t\tgetSystemHandlerArgs: function( args, client ) {\n\t\t\treturn [ client ].concat( args );\n\t\t},\n\t\n\t\thandle: function( client, input ) {\n\t\t\tvar inputDef = input;\n\t\t\tif ( typeof input === \"undefined\" ) {\n\t\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t\t}\n\t\t\tif ( typeof input === \"string\" ) {\n\t\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t\t}\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( typeof input !== \"object\" ) {\n\t\t\t\targs.splice( 1, 1, inputDef );\n\t\t\t}\n\t\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\t\tvar currentState = clientMeta.state;\n\t\t\tvar stateObj = this.states[ currentState ];\n\t\t\tvar handlerName;\n\t\t\tvar handler;\n\t\t\tvar isCatchAll = false;\n\t\t\tvar child;\n\t\t\tvar result;\n\t\t\tvar action;\n\t\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\t\tchild = this.configForState( currentState );\n\t\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\t\tinputDef.delegated = true;\n\t\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t\t} else {\n\t\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t\t}\n\t\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t\t);\n\t\t\t\t\tif ( !handler ) {\n\t\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t\t\tclientMeta.currentActionArgs = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\n\t\ttransition: function( client, newState ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar curState = clientMeta.state;\n\t\t\tvar curStateObj = this.states[ curState ];\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\tvar args = utils.getLeaklessArgs( arguments ).slice( 2 );\n\t\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\t\tif ( newStateObj ) {\n\t\t\t\t\tchild = this.configForState( newState );\n\t\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\t\tclientMeta.state = newState;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\t\ttoState: newState\n\t\t\t\t\t} );\n\t\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\t\tnewStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( events.TRANSITIONED, eventPayload );\n\t\t\t\t\tif ( child ) {\n\t\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tattemptedState: newState\n\t\t\t\t} ) );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferUntilTransition: function( client, stateName ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar stateList = _.isArray( stateName ) ? stateName : ( stateName ? [ stateName ] : undefined );\n\t\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\t\tvar queued = {\n\t\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\t\tuntilState: stateList,\n\t\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tqueuedArgs: queued\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferAndTransition: function( client, stateName ) {\n\t\t\tthis.deferUntilTransition( client, stateName );\n\t\t\tthis.transition( client, stateName );\n\t\t},\n\t\n\t\tprocessQueue: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar filterFn = function( item ) {\n\t\t\t\treturn ( ( !item.untilState ) || ( _.includes( item.untilState, clientMeta.state ) ) );\n\t\t\t};\n\t\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t\t_.each( toProcess, function( item ) {\n\t\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t\t}.bind( this ) );\n\t\t},\n\t\n\t\tclearQueue: function( client, name ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tif ( !name ) {\n\t\t\t\tclientMeta.inputQueue = [];\n\t\t\t} else {\n\t\t\t\t// first pass we remove the target state from any `untilState` array\n\t\t\t\t_.each( clientMeta.inputQueue, function( item ) {\n\t\t\t\t\titem.untilState = _.without( item.untilState, name );\n\t\t\t\t} );\n\t\t\t\t// second pass we clear out deferred events with empty untilState arrays\n\t\t\t\tvar filter = function( evnt ) {\n\t\t\t\t\treturn evnt.untilState.length !== 0;\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t\t}\n\t\t},\n\t\n\t\tcompositeState: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar state = clientMeta.state;\n\t\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\t\tif ( child ) {\n\t\t\t\tstate += \".\" + child.compositeState( client );\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t}, emitter.getInstance() );\n\t\n\tBehavioralFsm.extend = utils.extend;\n\t\n\tmodule.exports = BehavioralFsm;\n\n\n/***/ })\n/******/ ])\n});\n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBkYmNmMjQ5MTk1NGQwMmNkNjAzNyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFjaGluYS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiX1wiLFwiY29tbW9uanNcIjpcImxvZGFzaFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2hcIixcImFtZFwiOlwibG9kYXNoXCJ9Iiwid2VicGFjazovLy8uL3NyYy9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9Gc20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JlaGF2aW9yYWxGc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ1ZELGdEOzs7Ozs7QUNBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUEiLCJmaWxlIjoibWFjaGluYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJsb2Rhc2hcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWFjaGluYVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wibWFjaGluYVwiXSA9IGZhY3Rvcnkocm9vdFtcIl9cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZGJjZjI0OTE5NTRkMDJjZDYwMzciLCJ2YXIgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSggXCIuL2VtaXR0ZXJcIiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF8ubWVyZ2UoIGVtaXR0ZXIuaW5zdGFuY2UsIHtcblx0RnNtOiByZXF1aXJlKCBcIi4vRnNtXCIgKSxcblx0QmVoYXZpb3JhbEZzbTogcmVxdWlyZSggXCIuL0JlaGF2aW9yYWxGc21cIiApLFxuXHR1dGlsczogcmVxdWlyZSggXCIuL3V0aWxzXCIgKSxcblx0ZXZlbnRMaXN0ZW5lcnM6IHtcblx0XHRuZXdGc206IFtdXG5cdH1cbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hY2hpbmEuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJfXCIsXCJjb21tb25qc1wiOlwibG9kYXNoXCIsXCJjb21tb25qczJcIjpcImxvZGFzaFwiLFwiYW1kXCI6XCJsb2Rhc2hcIn1cbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWxzID0gcmVxdWlyZSggXCIuL3V0aWxzXCIgKTtcbnZhciBfID0gcmVxdWlyZSggXCJsb2Rhc2hcIiApO1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcblx0cmV0dXJuIHtcblx0XHRlbWl0OiBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0dmFyIGFyZ3MgPSB1dGlscy5nZXRMZWFrbGVzc0FyZ3MoIGFyZ3VtZW50cyApO1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBcIipcIiBdICkge1xuXHRcdFx0XHRfLmVhY2goIHRoaXMuZXZlbnRMaXN0ZW5lcnNbIFwiKlwiIF0sIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzLnVzZVNhZmVFbWl0ICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBleGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBleGNlcHRpb24uc3RhY2sgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fS5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gKSB7XG5cdFx0XHRcdF8uZWFjaCggdGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0sIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzLnVzZVNhZmVFbWl0ICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3Muc2xpY2UoIDEgKSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgYXJncy5zbGljZSggMSApICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0XHRcdFx0XHRcdFx0aWYgKCBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLmxvZyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggZXhjZXB0aW9uLnN0YWNrICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0uYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uOiBmdW5jdGlvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuZXZlbnRMaXN0ZW5lcnMgPSBzZWxmLmV2ZW50TGlzdGVuZXJzIHx8IHsgXCIqXCI6IFtdIH07XG5cdFx0XHRpZiAoICFzZWxmLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0c2VsZi5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdH1cblx0XHRcdHNlbGYuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRldmVudE5hbWU6IGV2ZW50TmFtZSxcblx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0XHRvZmY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYub2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdG9mZjogZnVuY3Rpb24oIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycyB8fCB7IFwiKlwiOiBbXSB9O1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdID0gXy53aXRob3V0KCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSwgY2FsbGJhY2sgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Z2V0SW5zdGFuY2U6IGdldEluc3RhbmNlLFxuXHRpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VtaXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgZXZlbnRzID0gcmVxdWlyZSggXCIuL2V2ZW50cy5qc1wiICk7XG52YXIgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcblxudmFyIG1ha2VGc21OYW1lc3BhY2UgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgbWFjaGluYUNvdW50ID0gMDtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcImZzbS5cIiArIG1hY2hpbmFDb3VudCsrO1xuXHR9O1xufSApKCk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRCZWhhdmlvcmFsT3B0aW9ucygpIHtcblx0cmV0dXJuIHtcblx0XHRpbml0aWFsU3RhdGU6IFwidW5pbml0aWFsaXplZFwiLFxuXHRcdGV2ZW50TGlzdGVuZXJzOiB7XG5cdFx0XHRcIipcIjogW11cblx0XHR9LFxuXHRcdHN0YXRlczoge30sXG5cdFx0bmFtZXNwYWNlOiBtYWtlRnNtTmFtZXNwYWNlKCksXG5cdFx0dXNlU2FmZUVtaXQ6IGZhbHNlLFxuXHRcdGhpZXJhcmNoeToge30sXG5cdFx0cGVuZGluZ0RlbGVnYXRpb25zOiB7fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0Q2xpZW50TWV0YSgpIHtcblx0cmV0dXJuIHtcblx0XHRpbnB1dFF1ZXVlOiBbXSxcblx0XHR0YXJnZXRSZXBsYXlTdGF0ZTogXCJcIixcblx0XHRzdGF0ZTogdW5kZWZpbmVkLFxuXHRcdHByaW9yU3RhdGU6IHVuZGVmaW5lZCxcblx0XHRwcmlvckFjdGlvbjogXCJcIixcblx0XHRjdXJyZW50QWN0aW9uOiBcIlwiLFxuXHRcdGN1cnJlbnRBY3Rpb25BcmdzOiB1bmRlZmluZWQsXG5cdFx0aW5FeGl0SGFuZGxlcjogZmFsc2Vcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVha2xlc3NBcmdzKCBhcmdzLCBzdGFydElkeCApIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHRmb3IgKCB2YXIgaSA9ICggc3RhcnRJZHggfHwgMCApOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIHtcblx0XHRyZXN1bHRbIGkgXSA9IGFyZ3NbIGkgXTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLypcblx0aGFuZGxlIC0+XG5cdFx0Y2hpbGQgPSBzdGF0ZU9iai5fY2hpbGQgJiYgc3RhdGVPYmouX2NoaWxkLmluc3RhbmNlO1xuXG5cdHRyYW5zaXRpb24gLT5cblx0XHRuZXdTdGF0ZU9iai5fY2hpbGQgPSBnZXRDaGlsZEZzbUluc3RhbmNlKCBuZXdTdGF0ZU9iai5fY2hpbGQgKTtcblx0XHRjaGlsZCA9IG5ld1N0YXRlT2JqLl9jaGlsZCAmJiBuZXdTdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2U7XG4qL1xuZnVuY3Rpb24gZ2V0Q2hpbGRGc21JbnN0YW5jZSggY29uZmlnICkge1xuXHRpZiAoICFjb25maWcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhciBjaGlsZEZzbURlZmluaXRpb24gPSB7fTtcblx0aWYgKCB0eXBlb2YgY29uZmlnID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIGlzIHRoaXMgYSBjb25maWcgb2JqZWN0IHdpdGggYSBmYWN0b3J5P1xuXHRcdGlmICggY29uZmlnLmZhY3RvcnkgKSB7XG5cdFx0XHRjaGlsZEZzbURlZmluaXRpb24gPSBjb25maWc7XG5cdFx0XHRjaGlsZEZzbURlZmluaXRpb24uaW5zdGFuY2UgPSBjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhc3N1bWluZyB0aGlzIGlzIGEgbWFjaGluYSBpbnN0YW5jZVxuXHRcdFx0Y2hpbGRGc21EZWZpbml0aW9uLmZhY3RvcnkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0Y2hpbGRGc21EZWZpbml0aW9uLmZhY3RvcnkgPSBjb25maWc7XG5cdH1cblx0Y2hpbGRGc21EZWZpbml0aW9uLmluc3RhbmNlID0gY2hpbGRGc21EZWZpbml0aW9uLmZhY3RvcnkoKTtcblx0cmV0dXJuIGNoaWxkRnNtRGVmaW5pdGlvbjtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9DaGlsZCggZnNtLCBjaGlsZCApIHtcblx0Ly8gTmVlZCB0byBpbnZlc3RpZ2F0ZSBwb3RlbnRpYWwgZm9yIGRpc2NhcmRlZCBldmVudFxuXHQvLyBsaXN0ZW5lciBtZW1vcnkgbGVhayBpbiBsb25nLXJ1bm5pbmcsIGRlZXBseS1uZXN0ZWQgaGllcmFyY2hpZXMuXG5cdHJldHVybiBjaGlsZC5vbiggXCIqXCIsIGZ1bmN0aW9uKCBldmVudE5hbWUsIGRhdGEgKSB7XG5cdFx0c3dpdGNoICggZXZlbnROYW1lICkge1xuXHRcdFx0Y2FzZSBldmVudHMuTk9fSEFORExFUjpcblx0XHRcdFx0aWYgKCAhZGF0YS50aWNrZXQgJiYgIWRhdGEuZGVsZWdhdGVkICYmIGRhdGEubmFtZXNwYWNlICE9PSBmc20ubmFtZXNwYWNlICkge1xuXHRcdFx0XHRcdC8vIE9rIC0gd2UncmUgZGVhbGluZyB3LyBhIGNoaWxkIGhhbmRsaW5nIGlucHV0IHRoYXQgc2hvdWxkIGJ1YmJsZSB1cFxuXHRcdFx0XHRcdGRhdGEuYXJnc1sgMSBdLmJ1YmJsaW5nID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB3ZSBkbyBOT1QgYnViYmxlIF9yZXNldCBpbnB1dHMgdXAgdG8gdGhlIHBhcmVudFxuXHRcdFx0XHRpZiAoIGRhdGEuaW5wdXRUeXBlICE9PSBcIl9yZXNldFwiICkge1xuXHRcdFx0XHRcdGZzbS5oYW5kbGUuYXBwbHkoIGZzbSwgZGF0YS5hcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGV2ZW50cy5IQU5ETElORyA6XG5cdFx0XHRcdHZhciB0aWNrZXQgPSBkYXRhLnRpY2tldDtcblx0XHRcdFx0aWYgKCB0aWNrZXQgJiYgZnNtLnBlbmRpbmdEZWxlZ2F0aW9uc1sgdGlja2V0IF0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGZzbS5wZW5kaW5nRGVsZWdhdGlvbnNbIHRpY2tldCBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZzbS5lbWl0KCBldmVudE5hbWUsIGRhdGEgKTsgLy8gcG9zc2libHkgdHJhbnNmb3JtIHBheWxvYWQ/XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0ZnNtLmVtaXQoIGV2ZW50TmFtZSwgZGF0YSApOyAvLyBwb3NzaWJseSB0cmFuc2Zvcm0gcGF5bG9hZD9cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIF9tYWNoS2V5cyBhcmUgbWVtYmVycyB3ZSB3YW50IHRvIHRyYWNrIGFjcm9zcyB0aGUgcHJvdG90eXBlIGNoYWluIG9mIGFuIGV4dGVuZGVkIEZTTSBjb25zdHJ1Y3RvclxuLy8gU2luY2Ugd2Ugd2FudCB0byBldmVudHVhbGx5IG1lcmdlIHRoZSBhZ2dyZWdhdGUgb2YgdGhvc2UgdmFsdWVzIG9udG8gdGhlIGluc3RhbmNlIHNvIHRoYXQgRlNNc1xuLy8gdGhhdCBzaGFyZSB0aGUgc2FtZSBleHRlbmRlZCBwcm90b3R5cGUgd29uJ3Qgc2hhcmUgc3RhdGUgKm9uKiB0aG9zZSBwcm90b3R5cGVzLlxudmFyIF9tYWNoS2V5cyA9IFsgXCJzdGF0ZXNcIiwgXCJpbml0aWFsU3RhdGVcIiBdO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uKCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcyApIHtcblx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdHZhciBmc207IC8vIHBsYWNlaG9sZGVyIGZvciBpbnN0YW5jZSBjb25zdHJ1Y3RvclxuXHR2YXIgbWFjaE9iaiA9IHt9OyAvLyBvYmplY3QgdXNlZCB0byBob2xkIGluaXRpYWxTdGF0ZSAmIHN0YXRlcyBmcm9tIHByb3RvdHlwZSBmb3IgaW5zdGFuY2UtbGV2ZWwgbWVyZ2luZ1xuXHR2YXIgQ3RvciA9IGZ1bmN0aW9uKCkge307IC8vIHBsYWNlaG9sZGVyIGN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnNlcnQgbGV2ZWwgaW4gcHJvdG90eXBlIGNoYWluXG5cblx0Ly8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuXHQvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcblx0Ly8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuXHRpZiAoIHByb3RvUHJvcHMgJiYgcHJvdG9Qcm9wcy5oYXNPd25Qcm9wZXJ0eSggXCJjb25zdHJ1Y3RvclwiICkgKSB7XG5cdFx0ZnNtID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3Rvcjtcblx0fSBlbHNlIHtcblx0XHQvLyBUaGUgZGVmYXVsdCBtYWNoaW5hIGNvbnN0cnVjdG9yICh3aGVuIHVzaW5nIGluaGVyaXRhbmNlKSBjcmVhdGVzIGFcblx0XHQvLyBkZWVwIGNvcHkgb2YgdGhlIHN0YXRlcy9pbml0aWFsU3RhdGUgdmFsdWVzIGZyb20gdGhlIHByb3RvdHlwZSBhbmRcblx0XHQvLyBleHRlbmRzIHRoZW0gb3ZlciB0aGUgaW5zdGFuY2Ugc28gdGhhdCB0aGV5J2xsIGJlIGluc3RhbmNlLWxldmVsLlxuXHRcdC8vIElmIGFuIG9wdGlvbnMgYXJnIChhcmdzWzBdKSBpcyBwYXNzZWQgaW4sIGEgc3RhdGVzIG9yIGludGlhbFN0YXRlXG5cdFx0Ly8gdmFsdWUgd2lsbCBiZSBwcmVmZXJyZWQgb3ZlciBhbnkgZGF0YSBwdWxsZWQgdXAgZnJvbSB0aGUgcHJvdG90eXBlLlxuXHRcdGZzbSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0XHRcdGFyZ3NbIDAgXSA9IGFyZ3NbIDAgXSB8fCB7fTtcblx0XHRcdHZhciBibGVuZGVkU3RhdGU7XG5cdFx0XHR2YXIgaW5zdGFuY2VTdGF0ZXMgPSBhcmdzWyAwIF0uc3RhdGVzIHx8IHt9O1xuXHRcdFx0YmxlbmRlZFN0YXRlID0gXy5tZXJnZSggXy5jbG9uZURlZXAoIG1hY2hPYmogKSwgeyBzdGF0ZXM6IGluc3RhbmNlU3RhdGVzIH0gKTtcblx0XHRcdGJsZW5kZWRTdGF0ZS5pbml0aWFsU3RhdGUgPSBhcmdzWyAwIF0uaW5pdGlhbFN0YXRlIHx8IHRoaXMuaW5pdGlhbFN0YXRlO1xuXHRcdFx0Xy5leHRlbmQoIGFyZ3NbIDAgXSwgYmxlbmRlZFN0YXRlICk7XG5cdFx0XHRwYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gSW5oZXJpdCBjbGFzcyAoc3RhdGljKSBwcm9wZXJ0aWVzIGZyb20gcGFyZW50LlxuXHRfLm1lcmdlKCBmc20sIHBhcmVudCApO1xuXG5cdC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG5cdC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdEN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcblx0ZnNtLnByb3RvdHlwZSA9IG5ldyBDdG9yKCk7XG5cblx0Ly8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG5cdC8vIGlmIHN1cHBsaWVkLlxuXHRpZiAoIHByb3RvUHJvcHMgKSB7XG5cdFx0Xy5leHRlbmQoIGZzbS5wcm90b3R5cGUsIHByb3RvUHJvcHMgKTtcblx0XHRfLm1lcmdlKCBtYWNoT2JqLCBfLnRyYW5zZm9ybSggcHJvdG9Qcm9wcywgZnVuY3Rpb24oIGFjY3VtLCB2YWwsIGtleSApIHtcblx0XHRcdGlmICggX21hY2hLZXlzLmluZGV4T2YoIGtleSApICE9PSAtMSApIHtcblx0XHRcdFx0YWNjdW1bIGtleSBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKSApO1xuXHR9XG5cblx0Ly8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG5cdGlmICggc3RhdGljUHJvcHMgKSB7XG5cdFx0Xy5tZXJnZSggZnNtLCBzdGF0aWNQcm9wcyApO1xuXHR9XG5cblx0Ly8gQ29ycmVjdGx5IHNldCBjaGlsZCdzIGBwcm90b3R5cGUuY29uc3RydWN0b3JgLlxuXHRmc20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnNtO1xuXG5cdC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWQgbGF0ZXIuXG5cdGZzbS5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXHRyZXR1cm4gZnNtO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVVVJRCgpIHtcblx0dmFyIHMgPSBbXTtcblx0dmFyIGhleERpZ2l0cyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSsrICkge1xuXHRcdHNbIGkgXSA9IGhleERpZ2l0cy5zdWJzdHIoIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAweDEwICksIDEgKTtcblx0fVxuXHRzWyAxNCBdID0gXCI0XCI7IC8vIGJpdHMgMTItMTUgb2YgdGhlIHRpbWVfaGlfYW5kX3ZlcnNpb24gZmllbGQgdG8gMDAxMFxuXHQvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cdHNbIDE5IF0gPSBoZXhEaWdpdHMuc3Vic3RyKCAoIHNbIDE5IF0gJiAweDMgKSB8IDB4OCwgMSApOyAvLyBiaXRzIDYtNyBvZiB0aGUgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZCB0byAwMVxuXHQvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXHRzWyA4IF0gPSBzWyAxMyBdID0gc1sgMTggXSA9IHNbIDIzIF0gPSBcIi1cIjtcblx0cmV0dXJuIHMuam9pbiggXCJcIiApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlVVVJRDogY3JlYXRlVVVJRCxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGdldERlZmF1bHRCZWhhdmlvcmFsT3B0aW9uczogZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zLFxuXHRnZXREZWZhdWx0T3B0aW9uczogZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zLFxuXHRnZXREZWZhdWx0Q2xpZW50TWV0YTogZ2V0RGVmYXVsdENsaWVudE1ldGEsXG5cdGdldENoaWxkRnNtSW5zdGFuY2U6IGdldENoaWxkRnNtSW5zdGFuY2UsXG5cdGdldExlYWtsZXNzQXJnczogZ2V0TGVha2xlc3NBcmdzLFxuXHRsaXN0ZW5Ub0NoaWxkOiBsaXN0ZW5Ub0NoaWxkLFxuXHRtYWtlRnNtTmFtZXNwYWNlOiBtYWtlRnNtTmFtZXNwYWNlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdE5FWFRfVFJBTlNJVElPTjogXCJ0cmFuc2l0aW9uXCIsXG5cdEhBTkRMSU5HOiBcImhhbmRsaW5nXCIsXG5cdEhBTkRMRUQ6IFwiaGFuZGxlZFwiLFxuXHROT19IQU5ETEVSOiBcIm5vaGFuZGxlclwiLFxuXHRUUkFOU0lUSU9OOiBcInRyYW5zaXRpb25cIixcblx0VFJBTlNJVElPTkVEOiBcInRyYW5zaXRpb25lZFwiLFxuXHRJTlZBTElEX1NUQVRFOiBcImludmFsaWRzdGF0ZVwiLFxuXHRERUZFUlJFRDogXCJkZWZlcnJlZFwiLFxuXHRORVdfRlNNOiBcIm5ld2ZzbVwiXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZWhhdmlvcmFsRnNtID0gcmVxdWlyZSggXCIuL0JlaGF2aW9yYWxGc21cIiApO1xudmFyIHV0aWxzID0gcmVxdWlyZSggXCIuL3V0aWxzXCIgKTtcbnZhciBfID0gcmVxdWlyZSggXCJsb2Rhc2hcIiApO1xuXG52YXIgRnNtID0ge1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0QmVoYXZpb3JhbEZzbS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0dGhpcy5lbnN1cmVDbGllbnRNZXRhKCk7XG5cdH0sXG5cdGluaXRDbGllbnQ6IGZ1bmN0aW9uIGluaXRDbGllbnQoKSB7XG5cdFx0dmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuXHRcdGlmICggIWluaXRpYWxTdGF0ZSApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJZb3UgbXVzdCBzcGVjaWZ5IGFuIGluaXRpYWwgc3RhdGUgZm9yIHRoaXMgRlNNXCIgKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5zdGF0ZXNbIGluaXRpYWxTdGF0ZSBdICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIlRoZSBpbml0aWFsIHN0YXRlIHNwZWNpZmllZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgc3RhdGVzIG9iamVjdC5cIiApO1xuXHRcdH1cblx0XHR0aGlzLnRyYW5zaXRpb24oIGluaXRpYWxTdGF0ZSApO1xuXHR9LFxuXHRlbnN1cmVDbGllbnRNZXRhOiBmdW5jdGlvbiBlbnN1cmVDbGllbnRNZXRhKCkge1xuXHRcdGlmICggIXRoaXMuX3N0YW1wZWQgKSB7XG5cdFx0XHR0aGlzLl9zdGFtcGVkID0gdHJ1ZTtcblx0XHRcdF8uZGVmYXVsdHMoIHRoaXMsIF8uY2xvbmVEZWVwKCB1dGlscy5nZXREZWZhdWx0Q2xpZW50TWV0YSgpICkgKTtcblx0XHRcdHRoaXMuaW5pdENsaWVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbnN1cmVDbGllbnRBcmc6IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdHZhciBfYXJncyA9IGFyZ3M7XG5cdFx0Ly8gd2UgbmVlZCB0byB0ZXN0IHRoZSBhcmdzIGFuZCB2ZXJpZnkgdGhhdCBpZiBhIGNsaWVudCBhcmcgaGFzXG5cdFx0Ly8gYmVlbiBwYXNzZWQsIGl0IG11c3QgYmUgdGhpcyBGU00gaW5zdGFuY2UgKHRoaXMgaXNuJ3QgYSBiZWhhdmlvcmFsIEZTTSlcblx0XHRpZiAoIHR5cGVvZiBfYXJnc1sgMCBdID09PSBcIm9iamVjdFwiICYmICEoIFwiaW5wdXRUeXBlXCIgaW4gX2FyZ3NbIDAgXSApICYmIF9hcmdzWyAwIF0gIT09IHRoaXMgKSB7XG5cdFx0XHRfYXJncy5zcGxpY2UoIDAsIDEsIHRoaXMgKTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgX2FyZ3NbIDAgXSAhPT0gXCJvYmplY3RcIiB8fCAoIHR5cGVvZiBfYXJnc1sgMCBdID09PSBcIm9iamVjdFwiICYmICggXCJpbnB1dFR5cGVcIiBpbiBfYXJnc1sgMCBdICkgKSApIHtcblx0XHRcdF9hcmdzLnVuc2hpZnQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9hcmdzO1xuXHR9LFxuXG5cdGdldEhhbmRsZXJBcmdzOiBmdW5jdGlvbiggYXJncywgaXNDYXRjaEFsbCApIHtcblx0XHQvLyBpbmRleCAwIGlzIHRoZSBjbGllbnQsIGluZGV4IDEgaXMgaW5wdXRUeXBlXG5cdFx0Ly8gaWYgd2UncmUgaW4gYSBjYXRjaC1hbGwgaGFuZGxlciwgaW5wdXQgdHlwZSBuZWVkcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYXJnc1xuXHRcdC8vIGlucHV0VHlwZSBtaWdodCBiZSBhbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8ganVzdCBnZXQgdGhlIGlucHV0VHlwZSBzdHJpbmcgaWYgc29cblx0XHR2YXIgX2FyZ3MgPSBhcmdzO1xuXHRcdHZhciBpbnB1dCA9IF9hcmdzWyAxIF07XG5cdFx0aWYgKCB0eXBlb2YgaW5wdXRUeXBlID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0X2FyZ3Muc3BsaWNlKCAxLCAxLCBpbnB1dC5pbnB1dFR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGlzQ2F0Y2hBbGwgP1xuXHRcdFx0X2FyZ3Muc2xpY2UoIDEgKSA6XG5cdFx0XHRfYXJncy5zbGljZSggMiApO1xuXHR9LFxuXG5cdGdldFN5c3RlbUhhbmRsZXJBcmdzOiBmdW5jdGlvbiggYXJncywgY2xpZW50ICkge1xuXHRcdHJldHVybiBhcmdzO1xuXHR9LFxuXG5cdC8vIFwiY2xhc3NpY1wiIG1hY2hpbmEgRlNNIGRvIG5vdCBlbWl0IHRoZSBjbGllbnQgcHJvcGVydHkgb24gZXZlbnRzICh3aGljaCB3b3VsZCBiZSB0aGUgRlNNIGl0c2VsZilcblx0YnVpbGRFdmVudFBheWxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcoIHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICkgKTtcblx0XHR2YXIgZGF0YSA9IGFyZ3NbIDEgXTtcblx0XHRpZiAoIF8uaXNQbGFpbk9iamVjdCggZGF0YSApICkge1xuXHRcdFx0cmV0dXJuIF8uZXh0ZW5kKCBkYXRhLCB7IG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyBkYXRhOiBkYXRhIHx8IG51bGwsIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfTtcblx0XHR9XG5cdH1cbn07XG5cbl8uZWFjaCggW1xuXHRcImhhbmRsZVwiLFxuXHRcInRyYW5zaXRpb25cIixcblx0XCJkZWZlclVudGlsVHJhbnNpdGlvblwiLFxuXHRcInByb2Nlc3NRdWV1ZVwiLFxuXHRcImNsZWFyUXVldWVcIlxuXSwgZnVuY3Rpb24oIG1ldGhvZFdpdGhDbGllbnRJbmplY3RlZCApIHtcblx0RnNtWyBtZXRob2RXaXRoQ2xpZW50SW5qZWN0ZWQgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcoIHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICkgKTtcblx0XHRyZXR1cm4gQmVoYXZpb3JhbEZzbS5wcm90b3R5cGVbIG1ldGhvZFdpdGhDbGllbnRJbmplY3RlZCBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdH07XG59ICk7XG5cbkZzbSA9IEJlaGF2aW9yYWxGc20uZXh0ZW5kKCBGc20gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGc207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9Gc20uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF8gPSByZXF1aXJlKCBcImxvZGFzaFwiICk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4vdXRpbHNcIiApO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCBcIi4vZW1pdHRlclwiICk7XG52YXIgdG9wTGV2ZWxFbWl0dGVyID0gZW1pdHRlci5pbnN0YW5jZTtcbnZhciBldmVudHMgPSByZXF1aXJlKCBcIi4vZXZlbnRzXCIgKTtcblxudmFyIE1BQ0hJTkFfUFJPUCA9IFwiX19tYWNoaW5hX19cIjtcblxuZnVuY3Rpb24gQmVoYXZpb3JhbEZzbSggb3B0aW9ucyApIHtcblx0Xy5leHRlbmQoIHRoaXMsIG9wdGlvbnMgKTtcblx0Xy5kZWZhdWx0cyggdGhpcywgdXRpbHMuZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zKCkgKTtcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0dG9wTGV2ZWxFbWl0dGVyLmVtaXQoIGV2ZW50cy5ORVdfRlNNLCB0aGlzICk7XG59XG5cbl8uZXh0ZW5kKCBCZWhhdmlvcmFsRnNtLnByb3RvdHlwZSwge1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHt9LFxuXG5cdGluaXRDbGllbnQ6IGZ1bmN0aW9uIGluaXRDbGllbnQoIGNsaWVudCApIHtcblx0XHR2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5pbml0aWFsU3RhdGU7XG5cdFx0aWYgKCAhaW5pdGlhbFN0YXRlICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIllvdSBtdXN0IHNwZWNpZnkgYW4gaW5pdGlhbCBzdGF0ZSBmb3IgdGhpcyBGU01cIiApO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLnN0YXRlc1sgaW5pdGlhbFN0YXRlIF0gKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVGhlIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdGF0ZXMgb2JqZWN0LlwiICk7XG5cdFx0fVxuXHRcdHRoaXMudHJhbnNpdGlvbiggY2xpZW50LCBpbml0aWFsU3RhdGUgKTtcblx0fSxcblxuXHRjb25maWdGb3JTdGF0ZTogZnVuY3Rpb24gY29uZmlnRm9yU3RhdGUoIG5ld1N0YXRlICkge1xuXHRcdHZhciBuZXdTdGF0ZU9iaiA9IHRoaXMuc3RhdGVzWyBuZXdTdGF0ZSBdO1xuXHRcdHZhciBjaGlsZDtcblx0XHRfLmVhY2goIHRoaXMuaGllcmFyY2h5LCBmdW5jdGlvbiggY2hpbGRMaXN0ZW5lciwga2V5ICkge1xuXHRcdFx0aWYgKCBjaGlsZExpc3RlbmVyICYmIHR5cGVvZiBjaGlsZExpc3RlbmVyLm9mZiA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRjaGlsZExpc3RlbmVyLm9mZigpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggbmV3U3RhdGVPYmouX2NoaWxkICkge1xuXHRcdFx0bmV3U3RhdGVPYmouX2NoaWxkID0gdXRpbHMuZ2V0Q2hpbGRGc21JbnN0YW5jZSggbmV3U3RhdGVPYmouX2NoaWxkICk7XG5cdFx0XHRjaGlsZCA9IG5ld1N0YXRlT2JqLl9jaGlsZCAmJiBuZXdTdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2U7XG5cdFx0XHR0aGlzLmhpZXJhcmNoeVsgY2hpbGQubmFtZXNwYWNlIF0gPSB1dGlscy5saXN0ZW5Ub0NoaWxkKCB0aGlzLCBjaGlsZCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGlsZDtcblx0fSxcblxuXHRlbnN1cmVDbGllbnRNZXRhOiBmdW5jdGlvbiBlbnN1cmVDbGllbnRNZXRhKCBjbGllbnQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY2xpZW50ICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIkFuIEZTTSBjbGllbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIgKTtcblx0XHR9XG5cdFx0Y2xpZW50WyBNQUNISU5BX1BST1AgXSA9IGNsaWVudFsgTUFDSElOQV9QUk9QIF0gfHwge307XG5cdFx0aWYgKCAhY2xpZW50WyBNQUNISU5BX1BST1AgXVsgdGhpcy5uYW1lc3BhY2UgXSApIHtcblx0XHRcdGNsaWVudFsgTUFDSElOQV9QUk9QIF1bIHRoaXMubmFtZXNwYWNlIF0gPSBfLmNsb25lRGVlcCggdXRpbHMuZ2V0RGVmYXVsdENsaWVudE1ldGEoKSApO1xuXHRcdFx0dGhpcy5pbml0Q2xpZW50KCBjbGllbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaWVudFsgTUFDSElOQV9QUk9QIF1bIHRoaXMubmFtZXNwYWNlIF07XG5cdH0sXG5cblx0YnVpbGRFdmVudFBheWxvYWQ6IGZ1bmN0aW9uKCBjbGllbnQsIGRhdGEgKSB7XG5cdFx0aWYgKCBfLmlzUGxhaW5PYmplY3QoIGRhdGEgKSApIHtcblx0XHRcdHJldHVybiBfLmV4dGVuZCggZGF0YSwgeyBjbGllbnQ6IGNsaWVudCwgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IGNsaWVudDogY2xpZW50LCBkYXRhOiBkYXRhIHx8IG51bGwsIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0SGFuZGxlckFyZ3M6IGZ1bmN0aW9uKCBhcmdzLCBpc0NhdGNoQWxsICkge1xuXHRcdC8vIGluZGV4IDAgaXMgdGhlIGNsaWVudCwgaW5kZXggMSBpcyBpbnB1dFR5cGVcblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGNhdGNoLWFsbCBoYW5kbGVyLCBpbnB1dCB0eXBlIG5lZWRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBhcmdzXG5cdFx0Ly8gaW5wdXRUeXBlIG1pZ2h0IGJlIGFuIG9iamVjdCwgc28gd2UgbmVlZCB0byBqdXN0IGdldCB0aGUgaW5wdXRUeXBlIHN0cmluZyBpZiBzb1xuXHRcdHZhciBfYXJncyA9IGFyZ3Muc2xpY2UoIDAgKTtcblx0XHR2YXIgaW5wdXQgPSBfYXJnc1sgMSBdO1xuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0X2FyZ3Muc3BsaWNlKCAxLCAxLCBpbnB1dC5pbnB1dFR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGlzQ2F0Y2hBbGwgP1xuXHRcdFx0X2FyZ3MgOlxuXHRcdFx0WyBfYXJnc1sgMCBdIF0uY29uY2F0KCBfYXJncy5zbGljZSggMiApICk7XG5cdH0sXG5cblx0Z2V0U3lzdGVtSGFuZGxlckFyZ3M6IGZ1bmN0aW9uKCBhcmdzLCBjbGllbnQgKSB7XG5cdFx0cmV0dXJuIFsgY2xpZW50IF0uY29uY2F0KCBhcmdzICk7XG5cdH0sXG5cblx0aGFuZGxlOiBmdW5jdGlvbiggY2xpZW50LCBpbnB1dCApIHtcblx0XHR2YXIgaW5wdXREZWYgPSBpbnB1dDtcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJUaGUgaW5wdXQgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBGU00ncyBoYW5kbGUgbWV0aG9kIGlzIHVuZGVmaW5lZC4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyB0aGUgaW5wdXQgbmFtZT9cIiApO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlucHV0RGVmID0geyBpbnB1dFR5cGU6IGlucHV0LCBkZWxlZ2F0ZWQ6IGZhbHNlLCB0aWNrZXQ6IHVuZGVmaW5lZCB9O1xuXHRcdH1cblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0dmFyIGFyZ3MgPSB1dGlscy5nZXRMZWFrbGVzc0FyZ3MoIGFyZ3VtZW50cyApO1xuXHRcdGlmICggdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0YXJncy5zcGxpY2UoIDEsIDEsIGlucHV0RGVmICk7XG5cdFx0fVxuXHRcdGNsaWVudE1ldGEuY3VycmVudEFjdGlvbkFyZ3MgPSBhcmdzLnNsaWNlKCAxICk7XG5cdFx0dmFyIGN1cnJlbnRTdGF0ZSA9IGNsaWVudE1ldGEuc3RhdGU7XG5cdFx0dmFyIHN0YXRlT2JqID0gdGhpcy5zdGF0ZXNbIGN1cnJlbnRTdGF0ZSBdO1xuXHRcdHZhciBoYW5kbGVyTmFtZTtcblx0XHR2YXIgaGFuZGxlcjtcblx0XHR2YXIgaXNDYXRjaEFsbCA9IGZhbHNlO1xuXHRcdHZhciBjaGlsZDtcblx0XHR2YXIgcmVzdWx0O1xuXHRcdHZhciBhY3Rpb247XG5cdFx0aWYgKCAhY2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyICkge1xuXHRcdFx0Y2hpbGQgPSB0aGlzLmNvbmZpZ0ZvclN0YXRlKCBjdXJyZW50U3RhdGUgKTtcblx0XHRcdGlmICggY2hpbGQgJiYgIXRoaXMucGVuZGluZ0RlbGVnYXRpb25zWyBpbnB1dERlZi50aWNrZXQgXSAmJiAhaW5wdXREZWYuYnViYmxpbmcgKSB7XG5cdFx0XHRcdGlucHV0RGVmLnRpY2tldCA9ICggaW5wdXREZWYudGlja2V0IHx8IHV0aWxzLmNyZWF0ZVVVSUQoKSApO1xuXHRcdFx0XHRpbnB1dERlZi5kZWxlZ2F0ZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1sgaW5wdXREZWYudGlja2V0IF0gPSB7IGRlbGVnYXRlZFRvOiBjaGlsZC5uYW1lc3BhY2UgfTtcblx0XHRcdFx0Ly8gV0FSTklORyAtIHJldHVybmluZyBhIHZhbHVlIGZyb20gYGhhbmRsZWAgb24gY2hpbGQgRlNNcyBpcyBub3QgcmVhbGx5IHN1cHBvcnRlZC5cblx0XHRcdFx0Ly8gSWYgeW91IG5lZWQgdG8gcmV0dXJuIHZhbHVlcyBmcm9tIGNoaWxkIEZTTSBpbnB1dCBoYW5kbGVycywgdXNlIGV2ZW50cyBpbnN0ZWFkLlxuXHRcdFx0XHRyZXN1bHQgPSBjaGlsZC5oYW5kbGUuYXBwbHkoIGNoaWxkLCBhcmdzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGlucHV0RGVmLnRpY2tldCAmJiB0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1sgaW5wdXREZWYudGlja2V0IF0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucGVuZGluZ0RlbGVnYXRpb25zWyBpbnB1dERlZi50aWNrZXQgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYW5kbGVyTmFtZSA9IHN0YXRlT2JqWyBpbnB1dERlZi5pbnB1dFR5cGUgXSA/IGlucHV0RGVmLmlucHV0VHlwZSA6IFwiKlwiO1xuXHRcdFx0XHRpc0NhdGNoQWxsID0gKCBoYW5kbGVyTmFtZSA9PT0gXCIqXCIgKTtcblx0XHRcdFx0aGFuZGxlciA9ICggc3RhdGVPYmpbIGhhbmRsZXJOYW1lIF0gfHwgdGhpc1sgaGFuZGxlck5hbWUgXSApIHx8IHRoaXNbIFwiKlwiIF07XG5cdFx0XHRcdGFjdGlvbiA9IGNsaWVudE1ldGEuc3RhdGUgKyBcIi5cIiArIGhhbmRsZXJOYW1lO1xuXHRcdFx0XHRjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb24gPSBhY3Rpb247XG5cdFx0XHRcdHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKFxuXHRcdFx0XHRcdGNsaWVudCxcblx0XHRcdFx0XHR7IGlucHV0VHlwZTogaW5wdXREZWYuaW5wdXRUeXBlLCBkZWxlZ2F0ZWQ6IGlucHV0RGVmLmRlbGVnYXRlZCwgdGlja2V0OiBpbnB1dERlZi50aWNrZXQgfVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoICFoYW5kbGVyICkge1xuXHRcdFx0XHRcdHRoaXMuZW1pdCggZXZlbnRzLk5PX0hBTkRMRVIsIF8uZXh0ZW5kKCB7IGFyZ3M6IGFyZ3MgfSwgZXZlbnRQYXlsb2FkICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5IQU5ETElORywgZXZlbnRQYXlsb2FkICk7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gaGFuZGxlci5hcHBseSggdGhpcywgdGhpcy5nZXRIYW5kbGVyQXJncyggYXJncywgaXNDYXRjaEFsbCApICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGhhbmRsZXI7XG5cdFx0XHRcdFx0XHR0aGlzLnRyYW5zaXRpb24oIGNsaWVudCwgaGFuZGxlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5IQU5ETEVELCBldmVudFBheWxvYWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGllbnRNZXRhLnByaW9yQWN0aW9uID0gY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uO1xuXHRcdFx0XHRjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb24gPSBcIlwiO1xuXHRcdFx0XHRjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb25BcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKCBjbGllbnQsIG5ld1N0YXRlICkge1xuXHRcdHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKCBjbGllbnQgKTtcblx0XHR2YXIgY3VyU3RhdGUgPSBjbGllbnRNZXRhLnN0YXRlO1xuXHRcdHZhciBjdXJTdGF0ZU9iaiA9IHRoaXMuc3RhdGVzWyBjdXJTdGF0ZSBdO1xuXHRcdHZhciBuZXdTdGF0ZU9iaiA9IHRoaXMuc3RhdGVzWyBuZXdTdGF0ZSBdO1xuXHRcdHZhciBjaGlsZDtcblx0XHR2YXIgYXJncyA9IHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICkuc2xpY2UoIDIgKTtcblx0XHRpZiAoICFjbGllbnRNZXRhLmluRXhpdEhhbmRsZXIgJiYgbmV3U3RhdGUgIT09IGN1clN0YXRlICkge1xuXHRcdFx0aWYgKCBuZXdTdGF0ZU9iaiApIHtcblx0XHRcdFx0Y2hpbGQgPSB0aGlzLmNvbmZpZ0ZvclN0YXRlKCBuZXdTdGF0ZSApO1xuXHRcdFx0XHRpZiAoIGN1clN0YXRlT2JqICYmIGN1clN0YXRlT2JqLl9vbkV4aXQgKSB7XG5cdFx0XHRcdFx0Y2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRjdXJTdGF0ZU9iai5fb25FeGl0LmNhbGwoIHRoaXMsIGNsaWVudCApO1xuXHRcdFx0XHRcdGNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsaWVudE1ldGEudGFyZ2V0UmVwbGF5U3RhdGUgPSBuZXdTdGF0ZTtcblx0XHRcdFx0Y2xpZW50TWV0YS5wcmlvclN0YXRlID0gY3VyU3RhdGU7XG5cdFx0XHRcdGNsaWVudE1ldGEuc3RhdGUgPSBuZXdTdGF0ZTtcblx0XHRcdFx0dmFyIGV2ZW50UGF5bG9hZCA9IHRoaXMuYnVpbGRFdmVudFBheWxvYWQoIGNsaWVudCwge1xuXHRcdFx0XHRcdGZyb21TdGF0ZTogY2xpZW50TWV0YS5wcmlvclN0YXRlLFxuXHRcdFx0XHRcdGFjdGlvbjogY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uLFxuXHRcdFx0XHRcdHRvU3RhdGU6IG5ld1N0YXRlXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5lbWl0KCBldmVudHMuVFJBTlNJVElPTiwgZXZlbnRQYXlsb2FkICk7XG5cdFx0XHRcdGlmICggbmV3U3RhdGVPYmouX29uRW50ZXIgKSB7XG5cdFx0XHRcdFx0bmV3U3RhdGVPYmouX29uRW50ZXIuYXBwbHkoIHRoaXMsIHRoaXMuZ2V0U3lzdGVtSGFuZGxlckFyZ3MoIGFyZ3MsIGNsaWVudCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lbWl0KCBldmVudHMuVFJBTlNJVElPTkVELCBldmVudFBheWxvYWQgKTtcblx0XHRcdFx0aWYgKCBjaGlsZCApIHtcblx0XHRcdFx0XHRjaGlsZC5oYW5kbGUoIGNsaWVudCwgXCJfcmVzZXRcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjbGllbnRNZXRhLnRhcmdldFJlcGxheVN0YXRlID09PSBuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnByb2Nlc3NRdWV1ZSggY2xpZW50LCBldmVudHMuTkVYVF9UUkFOU0lUSU9OICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCBldmVudHMuSU5WQUxJRF9TVEFURSwgdGhpcy5idWlsZEV2ZW50UGF5bG9hZCggY2xpZW50LCB7XG5cdFx0XHRcdHN0YXRlOiBjbGllbnRNZXRhLnN0YXRlLFxuXHRcdFx0XHRhdHRlbXB0ZWRTdGF0ZTogbmV3U3RhdGVcblx0XHRcdH0gKSApO1xuXHRcdH1cblx0fSxcblxuXHRkZWZlclVudGlsVHJhbnNpdGlvbjogZnVuY3Rpb24oIGNsaWVudCwgc3RhdGVOYW1lICkge1xuXHRcdHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKCBjbGllbnQgKTtcblx0XHR2YXIgc3RhdGVMaXN0ID0gXy5pc0FycmF5KCBzdGF0ZU5hbWUgKSA/IHN0YXRlTmFtZSA6ICggc3RhdGVOYW1lID8gWyBzdGF0ZU5hbWUgXSA6IHVuZGVmaW5lZCApO1xuXHRcdGlmICggY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJncyApIHtcblx0XHRcdHZhciBxdWV1ZWQgPSB7XG5cdFx0XHRcdHR5cGU6IGV2ZW50cy5ORVhUX1RSQU5TSVRJT04sXG5cdFx0XHRcdHVudGlsU3RhdGU6IHN0YXRlTGlzdCxcblx0XHRcdFx0YXJnczogY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJnc1xuXHRcdFx0fTtcblx0XHRcdGNsaWVudE1ldGEuaW5wdXRRdWV1ZS5wdXNoKCBxdWV1ZWQgKTtcblx0XHRcdHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKCBjbGllbnQsIHtcblx0XHRcdFx0c3RhdGU6IGNsaWVudE1ldGEuc3RhdGUsXG5cdFx0XHRcdHF1ZXVlZEFyZ3M6IHF1ZXVlZFxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5lbWl0KCBldmVudHMuREVGRVJSRUQsIGV2ZW50UGF5bG9hZCApO1xuXHRcdH1cblx0fSxcblxuXHRkZWZlckFuZFRyYW5zaXRpb246IGZ1bmN0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApIHtcblx0XHR0aGlzLmRlZmVyVW50aWxUcmFuc2l0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApO1xuXHRcdHRoaXMudHJhbnNpdGlvbiggY2xpZW50LCBzdGF0ZU5hbWUgKTtcblx0fSxcblxuXHRwcm9jZXNzUXVldWU6IGZ1bmN0aW9uKCBjbGllbnQgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdHZhciBmaWx0ZXJGbiA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuICggKCAhaXRlbS51bnRpbFN0YXRlICkgfHwgKCBfLmluY2x1ZGVzKCBpdGVtLnVudGlsU3RhdGUsIGNsaWVudE1ldGEuc3RhdGUgKSApICk7XG5cdFx0fTtcblx0XHR2YXIgdG9Qcm9jZXNzID0gXy5maWx0ZXIoIGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgZmlsdGVyRm4gKTtcblx0XHRjbGllbnRNZXRhLmlucHV0UXVldWUgPSBfLmRpZmZlcmVuY2UoIGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgdG9Qcm9jZXNzICk7XG5cdFx0Xy5lYWNoKCB0b1Byb2Nlc3MsIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0dGhpcy5oYW5kbGUuYXBwbHkoIHRoaXMsIFsgY2xpZW50IF0uY29uY2F0KCBpdGVtLmFyZ3MgKSApO1xuXHRcdH0uYmluZCggdGhpcyApICk7XG5cdH0sXG5cblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIGNsaWVudCwgbmFtZSApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0aWYgKCAhbmFtZSApIHtcblx0XHRcdGNsaWVudE1ldGEuaW5wdXRRdWV1ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBmaXJzdCBwYXNzIHdlIHJlbW92ZSB0aGUgdGFyZ2V0IHN0YXRlIGZyb20gYW55IGB1bnRpbFN0YXRlYCBhcnJheVxuXHRcdFx0Xy5lYWNoKCBjbGllbnRNZXRhLmlucHV0UXVldWUsIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpdGVtLnVudGlsU3RhdGUgPSBfLndpdGhvdXQoIGl0ZW0udW50aWxTdGF0ZSwgbmFtZSApO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gc2Vjb25kIHBhc3Mgd2UgY2xlYXIgb3V0IGRlZmVycmVkIGV2ZW50cyB3aXRoIGVtcHR5IHVudGlsU3RhdGUgYXJyYXlzXG5cdFx0XHR2YXIgZmlsdGVyID0gZnVuY3Rpb24oIGV2bnQgKSB7XG5cdFx0XHRcdHJldHVybiBldm50LnVudGlsU3RhdGUubGVuZ3RoICE9PSAwO1xuXHRcdFx0fTtcblx0XHRcdGNsaWVudE1ldGEuaW5wdXRRdWV1ZSA9IF8uZmlsdGVyKCBjbGllbnRNZXRhLmlucHV0UXVldWUsIGZpbHRlciApO1xuXHRcdH1cblx0fSxcblxuXHRjb21wb3NpdGVTdGF0ZTogZnVuY3Rpb24oIGNsaWVudCApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0dmFyIHN0YXRlID0gY2xpZW50TWV0YS5zdGF0ZTtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLnN0YXRlc1tzdGF0ZV0uX2NoaWxkICYmIHRoaXMuc3RhdGVzW3N0YXRlXS5fY2hpbGQuaW5zdGFuY2U7XG5cdFx0aWYgKCBjaGlsZCApIHtcblx0XHRcdHN0YXRlICs9IFwiLlwiICsgY2hpbGQuY29tcG9zaXRlU3RhdGUoIGNsaWVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn0sIGVtaXR0ZXIuZ2V0SW5zdGFuY2UoKSApO1xuXG5CZWhhdmlvcmFsRnNtLmV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcmFsRnNtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQmVoYXZpb3JhbEZzbS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dbcf2491954d02cd6037","var _ = require( \"lodash\" );\nvar emitter = require( \"./emitter\" );\n\nmodule.exports = _.merge( emitter.instance, {\n\tFsm: require( \"./Fsm\" ),\n\tBehavioralFsm: require( \"./BehavioralFsm\" ),\n\tutils: require( \"./utils\" ),\n\teventListeners: {\n\t\tnewFsm: []\n\t}\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/machina.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n// module id = 1\n// module chunks = 0","var utils = require( \"./utils\" );\nvar _ = require( \"lodash\" );\n\nfunction getInstance() {\n\treturn {\n\t\temit: function( eventName ) {\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind( this ) );\n\t\t\t}\n\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind( this ) );\n\t\t\t}\n\t\t},\n\n\t\ton: function( eventName, callback ) {\n\t\t\tvar self = this;\n\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t}\n\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\treturn {\n\t\t\t\teventName: eventName,\n\t\t\t\tcallback: callback,\n\t\t\t\toff: function() {\n\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\toff: function( eventName, callback ) {\n\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\tif ( !eventName ) {\n\t\t\t\tthis.eventListeners = {};\n\t\t\t} else {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t} else {\n\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tgetInstance: getInstance,\n\tinstance: getInstance()\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/emitter.js\n// module id = 2\n// module chunks = 0","var slice = [].slice;\nvar events = require( \"./events.js\" );\nvar _ = require( \"lodash\" );\n\nvar makeFsmNamespace = ( function() {\n\tvar machinaCount = 0;\n\treturn function() {\n\t\treturn \"fsm.\" + machinaCount++;\n\t};\n} )();\n\nfunction getDefaultBehavioralOptions() {\n\treturn {\n\t\tinitialState: \"uninitialized\",\n\t\teventListeners: {\n\t\t\t\"*\": []\n\t\t},\n\t\tstates: {},\n\t\tnamespace: makeFsmNamespace(),\n\t\tuseSafeEmit: false,\n\t\thierarchy: {},\n\t\tpendingDelegations: {}\n\t};\n}\n\nfunction getDefaultClientMeta() {\n\treturn {\n\t\tinputQueue: [],\n\t\ttargetReplayState: \"\",\n\t\tstate: undefined,\n\t\tpriorState: undefined,\n\t\tpriorAction: \"\",\n\t\tcurrentAction: \"\",\n\t\tcurrentActionArgs: undefined,\n\t\tinExitHandler: false\n\t};\n}\n\nfunction getLeaklessArgs( args, startIdx ) {\n\tvar result = [];\n\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\tresult[ i ] = args[ i ];\n\t}\n\treturn result;\n}\n/*\n\thandle ->\n\t\tchild = stateObj._child && stateObj._child.instance;\n\n\ttransition ->\n\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\tchild = newStateObj._child && newStateObj._child.instance;\n*/\nfunction getChildFsmInstance( config ) {\n\tif ( !config ) {\n\t\treturn;\n\t}\n\tvar childFsmDefinition = {};\n\tif ( typeof config === \"object\" ) {\n\t\t// is this a config object with a factory?\n\t\tif ( config.factory ) {\n\t\t\tchildFsmDefinition = config;\n\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t} else {\n\t\t\t// assuming this is a machina instance\n\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\treturn config;\n\t\t\t};\n\t\t}\n\t} else if ( typeof config === \"function\" ) {\n\t\tchildFsmDefinition.factory = config;\n\t}\n\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\treturn childFsmDefinition;\n}\n\nfunction listenToChild( fsm, child ) {\n\t// Need to investigate potential for discarded event\n\t// listener memory leak in long-running, deeply-nested hierarchies.\n\treturn child.on( \"*\", function( eventName, data ) {\n\t\tswitch ( eventName ) {\n\t\t\tcase events.NO_HANDLER:\n\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t}\n\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase events.HANDLING :\n\t\t\t\tvar ticket = data.ticket;\n\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t}\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t}\n\t} );\n}\n\n// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n// that share the same extended prototype won't share state *on* those prototypes.\nvar _machKeys = [ \"states\", \"initialState\" ];\nvar extend = function( protoProps, staticProps ) {\n\tvar parent = this;\n\tvar fsm; // placeholder for instance constructor\n\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\n\t// The constructor function for the new subclass is either defined by you\n\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t// by us to simply call the parent's constructor.\n\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\tfsm = protoProps.constructor;\n\t} else {\n\t\t// The default machina constructor (when using inheritance) creates a\n\t\t// deep copy of the states/initialState values from the prototype and\n\t\t// extends them over the instance so that they'll be instance-level.\n\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t// value will be preferred over any data pulled up from the prototype.\n\t\tfsm = function() {\n\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\tvar blendedState;\n\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\tparent.apply( this, args );\n\t\t};\n\t}\n\n\t// Inherit class (static) properties from parent.\n\t_.merge( fsm, parent );\n\n\t// Set the prototype chain to inherit from `parent`, without calling\n\t// `parent`'s constructor function.\n\tCtor.prototype = parent.prototype;\n\tfsm.prototype = new Ctor();\n\n\t// Add prototype properties (instance properties) to the subclass,\n\t// if supplied.\n\tif ( protoProps ) {\n\t\t_.extend( fsm.prototype, protoProps );\n\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\taccum[ key ] = val;\n\t\t\t}\n\t\t} ) );\n\t}\n\n\t// Add static properties to the constructor function, if supplied.\n\tif ( staticProps ) {\n\t\t_.merge( fsm, staticProps );\n\t}\n\n\t// Correctly set child's `prototype.constructor`.\n\tfsm.prototype.constructor = fsm;\n\n\t// Set a convenience property in case the parent's prototype is needed later.\n\tfsm.__super__ = parent.prototype;\n\treturn fsm;\n};\n\nfunction createUUID() {\n\tvar s = [];\n\tvar hexDigits = \"0123456789abcdef\";\n\tfor ( var i = 0; i < 36; i++ ) {\n\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t}\n\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t/* jshint ignore:start */\n\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t/* jshint ignore:end */\n\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\treturn s.join( \"\" );\n}\n\nmodule.exports = {\n\tcreateUUID: createUUID,\n\textend: extend,\n\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\tgetDefaultOptions: getDefaultBehavioralOptions,\n\tgetDefaultClientMeta: getDefaultClientMeta,\n\tgetChildFsmInstance: getChildFsmInstance,\n\tgetLeaklessArgs: getLeaklessArgs,\n\tlistenToChild: listenToChild,\n\tmakeFsmNamespace: makeFsmNamespace\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 3\n// module chunks = 0","module.exports = {\n\tNEXT_TRANSITION: \"transition\",\n\tHANDLING: \"handling\",\n\tHANDLED: \"handled\",\n\tNO_HANDLER: \"nohandler\",\n\tTRANSITION: \"transition\",\n\tTRANSITIONED: \"transitioned\",\n\tINVALID_STATE: \"invalidstate\",\n\tDEFERRED: \"deferred\",\n\tNEW_FSM: \"newfsm\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/events.js\n// module id = 4\n// module chunks = 0","var BehavioralFsm = require( \"./BehavioralFsm\" );\nvar utils = require( \"./utils\" );\nvar _ = require( \"lodash\" );\n\nvar Fsm = {\n\tconstructor: function() {\n\t\tBehavioralFsm.apply( this, arguments );\n\t\tthis.ensureClientMeta();\n\t},\n\tinitClient: function initClient() {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( initialState );\n\t},\n\tensureClientMeta: function ensureClientMeta() {\n\t\tif ( !this._stamped ) {\n\t\t\tthis._stamped = true;\n\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\tthis.initClient();\n\t\t}\n\t\treturn this;\n\t},\n\n\tensureClientArg: function( args ) {\n\t\tvar _args = args;\n\t\t// we need to test the args and verify that if a client arg has\n\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t_args.splice( 0, 1, this );\n\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t_args.unshift( this );\n\t\t}\n\t\treturn _args;\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args;\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args.slice( 1 ) :\n\t\t\t_args.slice( 2 );\n\t},\n\n\tgetSystemHandlerArgs: function( args, client ) {\n\t\treturn args;\n\t},\n\n\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\tbuildEventPayload: function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\tvar data = args[ 1 ];\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t}\n\t}\n};\n\n_.each( [\n\t\"handle\",\n\t\"transition\",\n\t\"deferUntilTransition\",\n\t\"processQueue\",\n\t\"clearQueue\"\n], function( methodWithClientInjected ) {\n\tFsm[ methodWithClientInjected ] = function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t};\n} );\n\nFsm = BehavioralFsm.extend( Fsm );\n\nmodule.exports = Fsm;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Fsm.js\n// module id = 5\n// module chunks = 0","var _ = require( \"lodash\" );\nvar utils = require( \"./utils\" );\nvar emitter = require( \"./emitter\" );\nvar topLevelEmitter = emitter.instance;\nvar events = require( \"./events\" );\n\nvar MACHINA_PROP = \"__machina__\";\n\nfunction BehavioralFsm( options ) {\n\t_.extend( this, options );\n\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\tthis.initialize.apply( this, arguments );\n\ttopLevelEmitter.emit( events.NEW_FSM, this );\n}\n\n_.extend( BehavioralFsm.prototype, {\n\tinitialize: function() {},\n\n\tinitClient: function initClient( client ) {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( client, initialState );\n\t},\n\n\tconfigForState: function configForState( newState ) {\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\tchildListener.off();\n\t\t\t}\n\t\t} );\n\n\t\tif ( newStateObj._child ) {\n\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t}\n\n\t\treturn child;\n\t},\n\n\tensureClientMeta: function ensureClientMeta( client ) {\n\t\tif ( typeof client !== \"object\" ) {\n\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t}\n\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\tthis.initClient( client );\n\t\t}\n\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t},\n\n\tbuildEventPayload: function( client, data ) {\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t}\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args.slice( 0 );\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof input === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args :\n\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t},\n\n\tgetSystemHandlerArgs: function( args, client ) {\n\t\treturn [ client ].concat( args );\n\t},\n\n\thandle: function( client, input ) {\n\t\tvar inputDef = input;\n\t\tif ( typeof input === \"undefined\" ) {\n\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t}\n\t\tif ( typeof input === \"string\" ) {\n\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t}\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\tif ( typeof input !== \"object\" ) {\n\t\t\targs.splice( 1, 1, inputDef );\n\t\t}\n\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\tvar currentState = clientMeta.state;\n\t\tvar stateObj = this.states[ currentState ];\n\t\tvar handlerName;\n\t\tvar handler;\n\t\tvar isCatchAll = false;\n\t\tvar child;\n\t\tvar result;\n\t\tvar action;\n\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\tchild = this.configForState( currentState );\n\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\tinputDef.delegated = true;\n\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t} else {\n\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t}\n\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\tclient,\n\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t);\n\t\t\t\tif ( !handler ) {\n\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t}\n\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t\tclientMeta.currentActionArgs = undefined;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\ttransition: function( client, newState ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar curState = clientMeta.state;\n\t\tvar curStateObj = this.states[ curState ];\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\tvar args = utils.getLeaklessArgs( arguments ).slice( 2 );\n\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\tif ( newStateObj ) {\n\t\t\t\tchild = this.configForState( newState );\n\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t}\n\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\tclientMeta.state = newState;\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\ttoState: newState\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\tnewStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );\n\t\t\t\t}\n\t\t\t\tthis.emit( events.TRANSITIONED, eventPayload );\n\t\t\t\tif ( child ) {\n\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t}\n\n\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tattemptedState: newState\n\t\t\t} ) );\n\t\t}\n\t},\n\n\tdeferUntilTransition: function( client, stateName ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar stateList = _.isArray( stateName ) ? stateName : ( stateName ? [ stateName ] : undefined );\n\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\tvar queued = {\n\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\tuntilState: stateList,\n\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t};\n\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tqueuedArgs: queued\n\t\t\t} );\n\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t}\n\t},\n\n\tdeferAndTransition: function( client, stateName ) {\n\t\tthis.deferUntilTransition( client, stateName );\n\t\tthis.transition( client, stateName );\n\t},\n\n\tprocessQueue: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar filterFn = function( item ) {\n\t\t\treturn ( ( !item.untilState ) || ( _.includes( item.untilState, clientMeta.state ) ) );\n\t\t};\n\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t_.each( toProcess, function( item ) {\n\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t}.bind( this ) );\n\t},\n\n\tclearQueue: function( client, name ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tif ( !name ) {\n\t\t\tclientMeta.inputQueue = [];\n\t\t} else {\n\t\t\t// first pass we remove the target state from any `untilState` array\n\t\t\t_.each( clientMeta.inputQueue, function( item ) {\n\t\t\t\titem.untilState = _.without( item.untilState, name );\n\t\t\t} );\n\t\t\t// second pass we clear out deferred events with empty untilState arrays\n\t\t\tvar filter = function( evnt ) {\n\t\t\t\treturn evnt.untilState.length !== 0;\n\t\t\t};\n\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t}\n\t},\n\n\tcompositeState: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar state = clientMeta.state;\n\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\tif ( child ) {\n\t\t\tstate += \".\" + child.compositeState( client );\n\t\t}\n\t\treturn state;\n\t}\n}, emitter.getInstance() );\n\nBehavioralFsm.extend = utils.extend;\n\nmodule.exports = BehavioralFsm;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/BehavioralFsm.js\n// module id = 6\n// module chunks = 0"]}