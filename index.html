<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Machina.js by ifandelse</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Machina.js</h1>
        <p>js ex machina - finite state machines in JavaScript</p>

        <p class="view"><a href="https://github.com/ifandelse/machina.js">View the Project on GitHub <small>ifandelse/machina.js</small></a></p>


        <ul>
          <li><a href="https://github.com/ifandelse/machina.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/ifandelse/machina.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/ifandelse/machina.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="machinajs---v043" class="anchor" href="#machinajs---v043" aria-hidden="true"><span class="octicon octicon-link"></span></a>machina.js - v0.4.3</h1>

<h2>
<a id="what-is-it" class="anchor" href="#what-is-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is it?</h2>

<p>Machina.js is a JavaScript framework for highly customizable finite state machines (FSMs).  Many of the ideas for machina have been loosely inspired by the Erlang/OTP FSM behaviors.</p>

<h2>
<a id="why-would-i-use-it" class="anchor" href="#why-would-i-use-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why would I use it?</h2>

<ul>
<li>Finite state machines offer a way to structure web client code in a very organized manner, and can make it much simpler to extend behavior for all or only key edge cases.

<ul>
<li>For example - instead of nested callbacks/deferreds, use an FSM to act as an "event aggregator" that is aware of when state needs to transition in the app once a set of conditions has been satisfied.</li>
<li>FSMs <em>can</em> work well for concerns like:

<ul>
<li>app "init" (bootstrapping your web client so that certain application behaviors are not available until all appropriate resources/data/behavior are present)</li>
<li>persistence concerns - offline vs online.  Abstract persistence behind an fsm that simply listens for messages (commands) to persist data.  Depending on the state of the client (offline vs online), the FSM will handle the activity accordingly - calling code never needs to know.</li>
<li>Often-changing-subsets of view or model elements.  Take a navigation menu, for example.  Depending on the context (i.e. - state), you may wish to show/hide certain menu options.  This usually turns out to be a handful of menu show-vs-hide combinations.  An FSM can abstract this well.</li>
</ul>
</li>
</ul>
</li>
<li>It's simple!  Machina makes the process of organizing the various states your fsm needs to know about - and the kinds of events each state can handle - intuitive to set up, and to read.</li>
<li>Powerful integration.  By using a plugin like <a href="https://github.com/ifandelse/machina.postal">machina.postal</a>, your FSM instances can auto-wire into <a href="https://github.com/ifandelse/postal.js">postal.js</a> (a JavaScript message bus), enabling them decoupled communications with other components in your application.  This wires up both subscribers (for state handlers to be invoked) and publishers (to publish your FSM's events to the message bus).</li>
<li>Extend for more power.

<ul>
<li>Writing your own message bus/eventing wire-up plugin is fairly simple.  Look at <a href="https://github.com/ifandelse/machina.postal">machina.postal</a> for an example.</li>
<li>Hook into the top level "newFsm" event to give other components in your app a handle to your FSMs as they are created.</li>
</ul>
</li>
</ul>

<h2>
<a id="how-do-i-use-it" class="anchor" href="#how-do-i-use-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>How do I use it?</h2>

<p>(The <a href="https://github.com/ifandelse/machina.js/wiki">wiki</a> has more extensive API documentation. Also, be sure to check out the example folder in this repository for more in-depth demos - especially if you're interested in a working 'connectivity' FSM. The example below is just scratching the surface of one...)</p>

<p>Creating an FSM:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> storageFsm <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">machina.Fsm</span>({
    <span class="pl-en">applicationOffline</span>: <span class="pl-st">function</span>() {
        <span class="pl-s">var</span> offline <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-c">// checks window.navigator.online and more, sets the offline value</span>
        <span class="pl-k">return</span> offline;
    },

    <span class="pl-en">verifyState</span>: <span class="pl-st">function</span>( <span class="pl-vpf">payload</span> ) {
        <span class="pl-k">if</span>( <span class="pl-v">this</span>.applicationOffline() <span class="pl-k">&amp;&amp;</span> <span class="pl-v">this</span>.state <span class="pl-k">!==</span> <span class="pl-s1"><span class="pl-pds">"</span>offline<span class="pl-pds">"</span></span> ) {
            <span class="pl-v">this</span>.offlineMarkerTime <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Date</span>();
            <span class="pl-v">this</span>.transition(<span class="pl-s1"><span class="pl-pds">"</span>offline<span class="pl-pds">"</span></span>);
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">else</span> <span class="pl-k">if</span> ( <span class="pl-k">!</span><span class="pl-v">this</span>.applicationOffline() <span class="pl-k">&amp;&amp;</span> <span class="pl-v">this</span>.state <span class="pl-k">===</span> <span class="pl-s1"><span class="pl-pds">"</span>offline<span class="pl-pds">"</span></span> ) {
            <span class="pl-v">this</span>.transition( <span class="pl-s1"><span class="pl-pds">"</span>online<span class="pl-pds">"</span></span> );
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    },

    initialState<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>offline<span class="pl-pds">"</span></span>,

    states <span class="pl-k">:</span> {
        <span class="pl-s1"><span class="pl-pds">"</span>online<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-st">function</span>() {
                <span class="pl-v">this</span>.handle(<span class="pl-s1"><span class="pl-pds">"</span>sync.customer<span class="pl-pds">"</span></span>);
            },

            <span class="pl-s1"><span class="pl-pds">"</span><span class="pl-en">save.customer</span><span class="pl-pds">"</span></span> : <span class="pl-st">function</span>( <span class="pl-vpf">payload</span> ) {
                <span class="pl-k">if</span>( <span class="pl-v">this</span>.verifyState() ) {
                    storage.saveToRemote( payload );
                }
            },

            <span class="pl-s1"><span class="pl-pds">"</span><span class="pl-en">sync.customer</span><span class="pl-pds">"</span></span> : <span class="pl-st">function</span>() {
                <span class="pl-k">if</span>( <span class="pl-v">this</span>.verifyState( payload ) ) {
                    <span class="pl-s">var</span> unsynced <span class="pl-k">=</span> storage.getFromLocal( { startTime<span class="pl-k">:</span> <span class="pl-v">this</span>.offlineMarkerTime } );
                    <span class="pl-c">// Big assumption here!  In the real world,</span>
                    <span class="pl-c">// we'd batch this sync in reasonable chunks.</span>
                    storage.saveBatchToRemote( unsynced );
                    <span class="pl-v">this</span>.emit( <span class="pl-s1"><span class="pl-pds">"</span>CustomerSyncComplete<span class="pl-pds">"</span></span>, { customers<span class="pl-k">:</span> unsynced } );
                }
            }
        },

        <span class="pl-s1"><span class="pl-pds">"</span>offline<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
            <span class="pl-s1"><span class="pl-pds">"</span><span class="pl-en">save.customer</span><span class="pl-pds">"</span></span> : <span class="pl-st">function</span>( <span class="pl-vpf">payload</span> ) {
                <span class="pl-k">if</span>( <span class="pl-v">this</span>.verifyState() ) {
                    storage.saveToLocal( payload );
                }
            }
        }
    }
});</pre></div>

<p>In the above example, the developer has created an FSM with two possible states: <code>online</code> and <code>offline</code>.  While the fsm is in the <code>online</code> state, it will respond to <code>save.customer</code> and <code>sync.customer</code> events.  External code triggers these events by calling the <code>handle</code> method on the FSM.  For example <code>storageFsm.handle( "sync.customer", { other: "data" } )</code>.  The <code>handle</code> method first looks to see if a named handler exists matching the name of the one passed in, then also checks for a catch-all handler (indicated by the "*") if a named handler isn't found.  The <code>offline</code> state of the above FSM only responds to <code>save.customer</code> events.  If any other type of event name is passed to the <code>handle</code> method of the FSM, other than what each state explicitly handles, it is ignored.</p>

<p>In addition to the state/handler definitions, the above code example as shows that this particular FSM will start in the <code>offline</code> state, and can generate a <code>CustomerSyncComplete</code> custom event.</p>

<p>The <code>verifyState</code> and <code>applicationOffline</code> methods are custom to this instance of the FSM, and are not, of course, part of machina by default.</p>

<p>You can see in the above example that anytime the FSM handles an event, it first checks to see if the state needs to be transitioned between offline and online (via the <code>verifyState</code> call).  States can also have <code>_onEnter</code> and <code>_onExit</code> methods. <code>_onEnter</code> is fired immediately after the FSM transitions into that state and <code>_onExit</code> is fired immediately before transitioning to a new state.</p>

<p>Now that we've seen a quick example, let's do a whirlwind API tour.</p>

<h2>
<a id="have-more-questions" class="anchor" href="#have-more-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Have More Questions?</h2>

<p>Read the wiki and the source â€“ you might find your answer and more! Check out the <a href="https://github.com/ifandelse/machina.js/issues/4">issue</a> opened by <a href="https://github.com/burin" class="user-mention">@burin</a> - a <em>great</em> example of how to use github issues to ask questions, provide sample code, etc. I only ask that if you open an issue, that it be <em>focused on a specific problem or bug</em> (not wide, open ambiguity, please). We also have an IRC chat room on freenode: #machinajs. It's a quiet place, but I'll do my best to answer questions if they arise.</p>

<h2>
<a id="whirlwind-api-tour" class="anchor" href="#whirlwind-api-tour" aria-hidden="true"><span class="octicon octicon-link"></span></a>Whirlwind API Tour</h2>

<p>When you are creating a new FSM instance, <code>machina.Fsm</code> takes 1 argument - an options object.  Here's a breakdown of the members of this <code>options</code> object:</p>

<p><code>eventListeners</code> - An object of event names, associated with the array of event handlers subscribed to them.  (You are not required to declare the events your FSM can publish ahead of time - this is only for convenience if you want to add handlers as you create the instance.)</p>

<div class="highlight highlight-javascript"><pre>eventListeners<span class="pl-k">:</span> {
    MyEvent1<span class="pl-k">:</span> [<span class="pl-st">function</span>(<span class="pl-vpf">data</span>) { <span class="pl-en">console</span><span class="pl-s3">.log</span>(data); }],
    MyEvent2<span class="pl-k">:</span> [<span class="pl-st">function</span>(<span class="pl-vpf">data</span>) { <span class="pl-en">console</span><span class="pl-s3">.log</span>(data); }]
}</pre></div>

<p><code>states</code> - an object detailing the possible states the FSM can be in, plus the kinds of events/messages each state can handle.  States can have normal "handlers" as well as a catch-all handler ("*"), an <code>_onEnter</code> handler invoked when the FSM has transitioned into that state and an <code>_onExit</code> handler invoked when transitioning out of that state.</p>

<div class="highlight highlight-javascript"><pre>states<span class="pl-k">:</span> {
    <span class="pl-s1"><span class="pl-pds">"</span>uninitialized<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
        <span class="pl-en">_onEnter</span>: <span class="pl-st">function</span>() {
            <span class="pl-c">// do stuff immediately after we transition into uninitialized</span>
        },

        <span class="pl-s1"><span class="pl-pds">"</span><span class="pl-en">initialize</span><span class="pl-pds">"</span></span> : <span class="pl-st">function</span>( <span class="pl-vpf">payload</span> ) {
            <span class="pl-c">// handle an "initialize" event</span>
        },

        <span class="pl-en">_onExit</span>: <span class="pl-st">function</span>() {
            <span class="pl-c">// do stuff immediately before we transition out of uninitialized</span>
            <span class="pl-c">// Note: you can't transition or invoke another inside _onExit</span>
        }
    },

    <span class="pl-s1"><span class="pl-pds">"</span>ready<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
        <span class="pl-s1"><span class="pl-pds">"</span><span class="pl-en">*</span><span class="pl-pds">"</span></span> : <span class="pl-st">function</span>( <span class="pl-vpf">payload</span> ) {
            <span class="pl-c">// any message that comes while in the "ready" state will get handled here</span>
            <span class="pl-c">// unless it matches another "ready" handler exactly.</span>
        }
    }
}</pre></div>

<p><code>initialState</code> - the state in which the FSM will start.  As soon as the instance is created, the FSM calls the <code>transition</code> method to transition into this state.</p>

<p><code>namespace</code> - a name that indentifies the FSM if it's wired up to a message bus through a plugin.</p>

<p><code>initialize</code> - a function that will be executed as soon as the FSM instance has been created. This is the last step of the FSM's constructor function, prior to emitting that a new instance has been created, and transitioning (if applicable) into the initial state.</p>

<h3>
<a id="inheritance" class="anchor" href="#inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inheritance</h3>

<p>FSMs can be created via the <code>machina.Fsm</code> constructor function as described above, or you can create an 'extended' FSM constructor function by calling <code>machina.Fsm.extend()</code>.  If you are familiar with backbone.js, machina's inheritance is identical to how backbone objects work, except that machina performs a deep extend, which means you can inherit from an FSM, adding new handlers to a state defined by the base (and you can override already-declared handlers, etc.).  With this being the case, it's better to think of machina's inhertiance as "blending" and not just extending. Let's look at an example:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> BaseFsm <span class="pl-k">=</span> machina.Fsm.extend({
    <span class="pl-en">initialize</span>: <span class="pl-st">function</span>() {
        <span class="pl-c">// do stuff here if you want to perform more setup work</span>
        <span class="pl-c">// this executes prior to any state transitions or handler invocations</span>
    },
    states<span class="pl-k">:</span> {
        uninitialized<span class="pl-k">:</span> {
            <span class="pl-en">start</span>: <span class="pl-st">function</span>() {
                <span class="pl-v">this</span>.transition(<span class="pl-s1"><span class="pl-pds">"</span>first<span class="pl-pds">"</span></span>);
            }
        },
        first<span class="pl-k">:</span> {
            <span class="pl-en">handlerA</span> : <span class="pl-st">function</span>() {
                <span class="pl-c">// do stuff</span>
            }
        }
    }
});
<span class="pl-c">// getting an instance from our extended constructor function above</span>
<span class="pl-s">var</span> baseFsm <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">BaseFsm</span>();

<span class="pl-c">// taking the BaseFsm constructor function and doing more</span>
<span class="pl-s">var</span> ChildFsm <span class="pl-k">=</span> BaseFsm.extend({
    states<span class="pl-k">:</span> {
        uninitialized<span class="pl-k">:</span> {
            <span class="pl-en">skipToTheEnd</span>: <span class="pl-st">function</span>() {
                <span class="pl-v">this</span>.transition(<span class="pl-s1"><span class="pl-pds">"</span>second<span class="pl-pds">"</span></span>);
            }
        },
        first<span class="pl-k">:</span> {
            <span class="pl-en">handlerA</span> : <span class="pl-st">function</span>() {
                <span class="pl-v">this</span>.transition(<span class="pl-s1"><span class="pl-pds">"</span>second<span class="pl-pds">"</span></span>);
            }
            <span class="pl-en">handlerB</span> : <span class="pl-st">function</span>() {
                <span class="pl-c">// do some work...</span>
            }
        },
        second<span class="pl-k">:</span> {
            <span class="pl-en">handlerC</span> : <span class="pl-st">function</span>() {
                <span class="pl-c">// do stuff</span>
            }
        }
    }
});

<span class="pl-c">// This instance will have a blending of BaseFsm and ChildFsm's states/handlers</span>
<span class="pl-s">var</span> childFsm <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ChildFsm</span>();</pre></div>

<h2>
<a id="the-machinafsm-prototype" class="anchor" href="#the-machinafsm-prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a>The machina.Fsm Prototype</h2>

<p>Each instance of an machina FSM has the following methods available via it's prototype:</p>

<ul>
<li>
<code>emit(eventName, [other args...])</code> - looks in the <code>events</code> object for a matching event name, and then iterates through the subscriber callbacks for that event and invokes each one, passing in any additional args that were passed to <code>emit</code>. (NOTE: - this call is currently aliased as <code>emit</code> as well.)</li>
<li>
<code>handle(msgType, [other args...])</code> - This is the main way you should be interacting with an FSM instance (assuming no message bus is present).  It will try to find a matching eventName/msgType under the current state and invoke it, if one exists.  Otherwise it will look for a catch-all handler, or simply ignore the message and raise the "NoHandler" event.</li>
<li>
<code>transition(newState)</code> - Called when transitioning into a new state.</li>
<li>
<code>deferUntilTransition(stateName)</code> - calling this within a state handler function will queue the handler's arguments to be executed at a later time.  If you don't provide the <code>stateName</code> argument, it will replay the event after the next state transition.  Providing the <code>stateName</code> argument will queue the event until the FSM transitions into that state.</li>
<li>
<code>deferUntilNextHandler()</code> - calling this within a state handler function will queue the handler's arguments to be executed after the next handler is invoked.</li>
<li>
<code>processQueue()</code> - called internally during state transitions and after handler methods have been invoked.  This call processes any queued events (queued by use of <code>deferUntilTransition</code> and/or <code>deferUntilNextHandler</code>).</li>
<li>
<code>clearQueue(type, name)</code> - allows you to clear out queued events that have been deferred either until another handler or another state transition. The <code>type</code> parameter can be either "transition" or "handler".  If you pass "transition" for the <code>type</code>, then the optional <code>name</code> parameter allows you to clear events queued for a specific state transition. Not providing a <code>name</code> when the <code>type</code> is "transition" will clear out all events queued for <em>any</em> state transition.</li>
<li>
<code>on(eventName, callback)</code> - used to subscribe to events that the FSM generates.</li>
<li>
<code>off(eventName, callback)</code> - used to unsubscribe to FSM events.</li>
</ul>

<p>In addition to the prototype members, every instance of an FSM has these instance-specific values as well:</p>

<ul>
<li>
<code>_currentAction</code> - concatenates "{state}.{handler}" for the operation in progress.  This is provided as a convenience for both logging (if needed) and if you need to check during an operation to see if the last action taken is the same action being taken now.</li>
<li>
<code>_priorAction</code> - concatenates "{state}.{handler" for the last operation that took place.  See the above explanation for more context.</li>
<li>
<code>eventListeners</code> - an object containing the event names (keys) and an array of subscribers listening to the event.  You should not need to interact with this directly. Instead, use the <code>on</code> and <code>off</code> prototype methods.</li>
<li>
<code>eventQueue</code> - an array of input/events that have been deferred by calling <code>deferUntilTransition</code> or <code>deferUntilNextHandler</code>. This queue is processed automatically for you.</li>
<li>
<code>namespace</code> - the namespace value you passed in during instantiaton, or a default value machina provides.</li>
<li>
<code>priorState</code> - the last state in which the FSM was in before the current one.  This could be useful if you have conditional transition behavior as you move into a new state which depends on what state you're moving <em>from</em>.</li>
<li>
<code>state</code> - string value of the current state of the FSM.  This will match one of the state names in the <code>states</code> object.  Do <em>not</em> change this value directly.  Use the <code>transition()</code> method on the prototype to change an FSM's state.</li>
<li>
<code>states</code> - the object literal of states &amp; handlers you passed in when you created the FSM.</li>
<li>
<code>targetReplayState</code> - used internally during transitions to manage the proper replay of queued events if multiple transitions result from one initial transition.</li>
</ul>

<h2>
<a id="the-top-level-machina-object" class="anchor" href="#the-top-level-machina-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Top Level machina object</h2>

<p>The top level <code>machina</code> object has the following members:</p>

<ul>
<li>
<code>Fsm</code> - the constructor function used to create FSMs.</li>
<li>
<code>utils</code> - contains helper functions that can be overridden to change default behavior(s) in machina:

<ul>
<li>
<code>getDefaultOptions</code> - returns the default options object for any machina instance</li>
<li>
<code>makeFsmNamespace</code> - function that provides a default "channel" or "exchange" for an FSM instance.  (e.g. - fsm.0, fsm.1, etc.)</li>
</ul>
</li>
<li>
<code>on</code> - function used to subscribe a callback to top-level machina events (currently the only event published at this level is "newFsm")</li>
<li>
<code>off</code> - function used to unsubscribe a callback to top-level machina events.</li>
<li>
<code>eventListeners</code> - an object literal containing the top-level <code>emit</code> call as well as susbcribers to any top-level events.</li>
</ul>

<h2>
<a id="pulling-machina-into-your-environment" class="anchor" href="#pulling-machina-into-your-environment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pulling machina into your environment</h2>

<p>machina depends on <a href="https://lodash.com/">lodash (2.4.1 or greater)</a>. If you are using npm or bower - lodash will be pulled down automatically when you install machina - otherwise you'll need to grab it manually.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c">// If you're not using an AMD loader, machina is available on the window</span>
<span class="pl-s">var</span> MyFsm <span class="pl-k">=</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});

<span class="pl-c">// If you're using an AMD loader:</span>
<span class="pl-s3">require</span>([<span class="pl-s1"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>], <span class="pl-st">function</span>(<span class="pl-vpf">machina</span>){
    <span class="pl-k">return</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});
});

<span class="pl-c">// machina v0.3.x</span>
<span class="pl-c">// In node.js, the module returns a factory function:</span>
<span class="pl-s">var</span> lodash <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>lodash<span class="pl-pds">'</span></span>);
<span class="pl-s">var</span> machina <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>)(lodash);
<span class="pl-s">var</span> MyFsm <span class="pl-k">=</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});

<span class="pl-c">// This changed in v0.4 FYI - it no longer exports a factory:</span>
<span class="pl-s">var</span> machina <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>);</pre></div>

<h2>
<a id="build-tests--examples" class="anchor" href="#build-tests--examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Build, Tests &amp; Examples</h2>

<p>machina.js uses <a href="http://gulpjs.com/">gulp.js</a> to build.</p>

<ul>
<li>Install node.js (and consider using <a href="https://github.com/creationix/nvm">nvm</a> to manage your node versions)</li>
<li>run <code>npm install</code> &amp; <code>bower install</code> to install all dependencies</li>
<li>To build, run <code>npm run build</code> - then check the lib folder for the output</li>
<li>To run tests &amp; examples:

<ul>
<li>To run node-based tests: <code>npm run test</code>
</li>
<li>To run browser-based tests &amp; examples:

<ul>
<li>run <code>npm start</code>
</li>
<li>navigate in your browser to <a href="http://localhost:3080/">http://localhost:3080/</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<h2>
<a id="release-notes" class="anchor" href="#release-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Notes</h2>

<p>Go <a href="https://github.com/ifandelse/machina.js/blob/master/changelog.md">here</a> to see the changelog.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ifandelse">ifandelse</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-30321396-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>