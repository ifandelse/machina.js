<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Machina.js by ifandelse</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Machina.js</h1>
        <p class="header">js ex machina - finite state machines in JavaScript</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/ifandelse/machina.js/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/ifandelse/machina.js/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/ifandelse/machina.js">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/ifandelse">ifandelse</a></p>


      </header>
      <section>
        <h1>
<a id="machina-v100-1" class="anchor" href="#machina-v100-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>machina v1.0.0-1</h1>

<h2>
<a id="what-is-it" class="anchor" href="#what-is-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is it?</h2>

<p>Machina.js is a JavaScript framework for highly customizable finite state machines (FSMs).  Many of the ideas for machina have been <em>loosely</em> inspired by the Erlang/OTP FSM behaviors.</p>

<h2>
<a id="why-would-i-use-it" class="anchor" href="#why-would-i-use-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why Would I Use It?</h2>

<p>Finite state machines are a great conceptual model for many concerns facing developers – from conditional UI, connectivity monitoring &amp; management to initialization and more. State machines can simplify tangled paths of asynchronous code, they're easy to test, and they inherently lend themselves to helping you avoid unexpected edge-case-state pitfalls. machina aims to give you the tools you need to model state machines in JavaScript, without being too prescriptive on the problem domain you're solving for.</p>

<p>Some frequent use cases for machina:</p>

<ul>
<li>online/offline connectivity management</li>
<li>conditional UI (menus, navigation, workflow)</li>
<li>initiliazation of node.js processes or single-page-apps</li>
<li>responding to user input devices (remotes, keyboard, mouse, etc.)</li>
</ul>

<h3>
<a id="quick-example" class="anchor" href="#quick-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quick Example</h3>

<p>First - you need to include it in your environment (browser, node, etc.):</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c">// If you're not using an AMD loader, machina is available on the window</span>
<span class="pl-c">// Just make sure you have lodash loaded before machina</span>
<span class="pl-k">var</span> MyFsm <span class="pl-k">=</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});

<span class="pl-c">// If you're using an AMD loader:</span>
<span class="pl-c1">require</span>([<span class="pl-s"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>], <span class="pl-k">function</span>(<span class="pl-smi">machina</span>){
    <span class="pl-k">return</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});
});

<span class="pl-c">// node.js/CommonJS:</span>
<span class="pl-k">var</span> machina <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>);

<span class="pl-c">// FYI machina v0.3.x &amp; earlier returned a factory</span>
<span class="pl-c">// function in CommonJS environments:</span>
<span class="pl-k">var</span> lodash <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>lodash<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> machina <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>machina<span class="pl-pds">'</span></span>)(lodash);
<span class="pl-k">var</span> MyFsm <span class="pl-k">=</span> machina.Fsm.extend({ <span class="pl-c">/* your stuff */</span>});</pre></div>

<p>Great, now that we know how to pull it in, let's create an FSM to represent a vehicle traffic light at a pedestrian crosswalk:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> vehicleSignal <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">machina.Fsm</span>( {

    <span class="pl-c">// the initialize method is called right after the FSM</span>
    <span class="pl-c">// instance is constructed, giving you a place for any</span>
    <span class="pl-c">// setup behavior, etc. It receives the same arguments</span>
    <span class="pl-c">// (options) as the constructor function.</span>
    <span class="pl-en">initialize</span>: <span class="pl-k">function</span>( <span class="pl-smi">options</span> ) {
        <span class="pl-c">// your setup code goes here...</span>
    },

    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>vehicle-signal<span class="pl-pds">"</span></span>,

    <span class="pl-c">// `initialState` tells machina what state to start the FSM in.</span>
    <span class="pl-c">// The default value is "uninitialized". Not providing</span>
    <span class="pl-c">// this value will throw an exception in v1.0+</span>
    initialState<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>uninitialized<span class="pl-pds">"</span></span>,

    <span class="pl-c">// The states object's top level properties are the</span>
    <span class="pl-c">// states in which the FSM can exist. Each state object</span>
    <span class="pl-c">// contains input handlers for the different inputs</span>
    <span class="pl-c">// handled while in that state.</span>
    states<span class="pl-k">:</span> {
        uninitialized<span class="pl-k">:</span> {
            <span class="pl-c">// Input handlers are usually functions. They can</span>
            <span class="pl-c">// take arguments, too (even though this one doesn't)</span>
            <span class="pl-c">// The "*" handler is special (more on that in a bit)</span>
            <span class="pl-s"><span class="pl-pds">"</span><span class="pl-en">*</span><span class="pl-pds">"</span></span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.deferUntilTransition();
                <span class="pl-c">// the `transition` method takes a target state (as a string)</span>
                <span class="pl-c">// and transitions to it. You should NEVER directly assign the</span>
                <span class="pl-c">// state property on an FSM. Also - while it's certainly OK to</span>
                <span class="pl-c">// call `transition` externally, you usually end up with the</span>
                <span class="pl-c">// cleanest approach if you endeavor to transition *internally*</span>
                <span class="pl-c">// and just pass input to the FSM.</span>
                <span class="pl-v">this</span>.transition( <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span> );
            }
        },
        green<span class="pl-k">:</span> {
            <span class="pl-c">// _onEnter is a special handler that is invoked</span>
            <span class="pl-c">// immediately as the FSM transitions into the new state</span>
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">30000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">GREEN</span> } );
            },
            <span class="pl-c">// If all you need to do is transition to a new state</span>
            <span class="pl-c">// inside an input handler, you can provide the string</span>
            <span class="pl-c">// name of the state in place of the input handler function.</span>
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span>,
            <span class="pl-en">pedestrianWaiting</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.deferUntilTransition( <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span> );
            },
            <span class="pl-c">// _onExit is a special handler that is invoked just before</span>
            <span class="pl-c">// the FSM leaves the current state and transitions to another</span>
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>( <span class="pl-v">this</span>.timer );
            }
        },
        <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
            pedestrianWaiting<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>yellow<span class="pl-pds">"</span></span>
        },
        yellow<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">5000</span> );
                <span class="pl-c">// machina FSMs are event emitters. Here we're</span>
                <span class="pl-c">// emitting a custom event and data, etc.</span>
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">YELLOW</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>red<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>( <span class="pl-v">this</span>.timer );
            }
        },
        red<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">1000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">RED</span> } );
            },
            _reset<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>(<span class="pl-v">this</span>.timer);
            }
        }
    }

    <span class="pl-c">// While you can call the FSM's `handle` method externally, it doesn't</span>
    <span class="pl-c">// make for a terribly expressive API. As a general rule, you wrap calls</span>
    <span class="pl-c">// to `handle` with more semantically meaningful method calls like these:</span>
    <span class="pl-en">reset</span>: <span class="pl-k">function</span>() {
        <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>_reset<span class="pl-pds">"</span></span> );
    },

    <span class="pl-en">pedestrianWaiting</span>: <span class="pl-k">function</span>() {
        <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>pedestrianWaiting<span class="pl-pds">"</span></span> );
    }
} );

<span class="pl-c">// Now, to use it:</span>
<span class="pl-c">// This call causes the FSM to transition from uninitialized -&gt; green</span>
<span class="pl-c">// &amp; queues up pedestrianWaiting input, which replays after the timeout</span>
<span class="pl-c">// causes a transition to green-interruptible....which immediately</span>
<span class="pl-c">// transitions to yellow since we have a pedestrian waiting. After the</span>
<span class="pl-c">// next timeout, we end up in "red".</span>
vehicleSignal.pedestrianWaiting();
<span class="pl-c">// Once the FSM is in the "red" state, we can reset it to "green" by calling:</span>
vehicleSignal.<span class="pl-c1">reset</span>();</pre></div>

<p>Though the code comments give you a lot of detail, let's break down what's happening in the above FSM:</p>

<ul>
<li>When you are creating an FSM, the constructor takes one argument, the <code>options</code> arg - which is an object that contains (at least) the <code>states</code> &amp; <code>initialState</code> values for your FSM, as well as an optional <code>initialize</code> method (which is invoked at the end of the underlying constructor function) and any additional properties or methods you want on the FSM.</li>
<li>It can exist in one of five possible states: <code>uninitialized</code>, <code>green</code>, <code>green-interruptible</code>, <code>yellow</code> and <code>red</code>. (Only one state can be active at a time.)</li>
<li>The states themselves are objects under the <code>states</code> property on the FSM, and contain handlers whose names match the input types that the FSM accepts while in that state.</li>
<li>It starts in the <code>uninitialized</code> state.</li>
<li>It accepts input either by calling <code>handle</code> directly and passing the input type as a string (plus any arguments), or by calling top level methods you put on your FSM's prototype that wrap the calls to <code>handle</code> with a more expressive API.</li>
<li>You do <em>not</em> assign the state value of the FSM directly, instead, you use <code>transition(stateName)</code> to transition to a different state.</li>
<li>Special "input handlers" exist in machina: <code>_onEnter</code>, <code>_onExit</code> and <code>*</code>. In fact, the very first state (<code>uninitialized</code>) in this FSM is using <code>*</code>. It's the "catch-all" handler which, if provided, will match any input in that state that's not explicitly matched by name. In this case, any input handled in <code>uninitialized</code> will cause the FSM to defer the input (queue it up for replay after transitioning), and immediately transfer to <code>green</code>. (This is just to demonstrate how a start-up-only state can automatically transfer into active state(s) as clients begin using the FSM. )</li>
</ul>

<blockquote>
<p>Note - input handlers can return values. Just be aware that this is not reliable in hierarchical FSMs.</p>
</blockquote>

<h3>
<a id="going-further" class="anchor" href="#going-further" aria-hidden="true"><span class="octicon octicon-link"></span></a>Going Further</h3>

<p>machina provides two constructor functions for creating an FSM: <code>machina.Fsm</code> and <code>machina.BehavioralFsm</code>:</p>

<h4>
<a id="the-behavioralfsm-constructor" class="anchor" href="#the-behavioralfsm-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The BehavioralFsm Constructor</h4>

<p><code>BehavioralFsm</code> is new to machina as of v1.0 (though the <code>Fsm</code> constructor now inherits from it). The <code>BehavioralFsm</code> constructor lets you create an FSM that defines <em>behavior</em> (hence the name) that you want applied to multiple, separate instances of <em>state</em>. A <code>BehavioralFsm</code> instance does not (should not!) track state locally, on itself. For example, consider this scenario....where we get to twist our <code>vehicleSignal</code> FSM beyond reason: <img class="emoji" title=":smile:" alt=":smile:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" height="20" width="20" align="absmiddle"></p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> vehicleSignal <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">machina.BehavioralFsm</span>( {

    <span class="pl-en">initialize</span>: <span class="pl-k">function</span>( <span class="pl-smi">options</span> ) {
        <span class="pl-c">// your setup code goes here...</span>
    },

    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>vehicle-signal<span class="pl-pds">"</span></span>,

    initialState<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>uninitialized<span class="pl-pds">"</span></span>,

    states<span class="pl-k">:</span> {
        uninitialized<span class="pl-k">:</span> {
            <span class="pl-s"><span class="pl-pds">"</span><span class="pl-en">*</span><span class="pl-pds">"</span></span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                <span class="pl-v">this</span>.deferUntilTransition( client );
                <span class="pl-v">this</span>.transition( client, <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span> );
            }
        },
        green<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                client.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle(  client, <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">30000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { client<span class="pl-k">:</span> client, status<span class="pl-k">:</span> <span class="pl-c1">GREEN</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span>,
            <span class="pl-en">pedestrianWaiting</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                <span class="pl-v">this</span>.deferUntilTransition(  client, <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span> );
            },
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                <span class="pl-c1">clearTimeout</span>( client.timer );
            }
        },
        <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
            pedestrianWaiting<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>yellow<span class="pl-pds">"</span></span>
        },
        yellow<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                client.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( client, <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">5000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { client<span class="pl-k">:</span> client, status<span class="pl-k">:</span> <span class="pl-c1">YELLOW</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>red<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                <span class="pl-c1">clearTimeout</span>( client.timer );
            }
        },
        red<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                client.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( client, <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">1000</span> );
            },
            _reset<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
                <span class="pl-c1">clearTimeout</span>( client.timer );
            }
        }
    },

    <span class="pl-en">reset</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
        <span class="pl-v">this</span>.handle(  client, <span class="pl-s"><span class="pl-pds">"</span>_reset<span class="pl-pds">"</span></span> );
    },

    <span class="pl-en">pedestrianWaiting</span>: <span class="pl-k">function</span>( <span class="pl-smi">client</span> ) {
        <span class="pl-v">this</span>.handle( client, <span class="pl-s"><span class="pl-pds">"</span>pedestrianWaiting<span class="pl-pds">"</span></span> );
    }
} );

<span class="pl-c">// Now we can have multiple 'instances' of traffic lights that all share the same FSM:</span>
<span class="pl-k">var</span> light1 <span class="pl-k">=</span> { location<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Dijsktra Ave &amp; Hunt Blvd<span class="pl-pds">"</span></span>, direction<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>north-south<span class="pl-pds">"</span></span> };
<span class="pl-k">var</span> light2 <span class="pl-k">=</span> { location<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Dijsktra Ave &amp; Hunt Blvd<span class="pl-pds">"</span></span>, direction<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>east-west<span class="pl-pds">"</span></span> };

<span class="pl-c">// to use the behavioral fsm, we pass the "client" in as the first arg to API calls:</span>
vehicleSignal.pedestrianWaiting( light1 );

<span class="pl-c">// Now let's signal a pedestrian waiting at light2</span>
vehicleSignal.pedestrianWaiting( light2 );

<span class="pl-c">// if you were to inspect light1 and light2, you'd see they both have</span>
<span class="pl-c">// a __machina__ property, which contains metadata related to this FSM.</span>
<span class="pl-c">// For example, light1.__machina__.vehicleSignal.state might be "green"</span>
<span class="pl-c">// and light2.__machina__.vehicleSignal.state might be "yellow" (depending</span>
<span class="pl-c">// on when you check). The point is - the "clients' state" is tracked</span>
<span class="pl-c">// separately from each other, and from the FSM. Here's a snapshot of</span>
<span class="pl-c">// light1 right after the vehicleSignal.pedestrianWaiting( light1 ) call:</span>

{
  <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Dijsktra Ave &amp; Hunt Blvd<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>direction<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>north-south<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>__machina__<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>vehicle-signal<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>inputQueue<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>transition<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>untilState<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green-interruptible<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>args<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
            {
              <span class="pl-s"><span class="pl-pds">"</span>inputType<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>pedestrianWaiting<span class="pl-pds">"</span></span>,
              <span class="pl-s"><span class="pl-pds">"</span>delegated<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">false</span>
            }
          ]
        }
      ],
      <span class="pl-s"><span class="pl-pds">"</span>targetReplayState<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>priorState<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>uninitialized<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>priorAction<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>currentAction<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>currentActionArgs<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>inputType<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>pedestrianWaiting<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>delegated<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">false</span>
        }
      ],
      <span class="pl-s"><span class="pl-pds">"</span>inExitHandler<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">false</span>
    }
  },
  <span class="pl-s"><span class="pl-pds">"</span>timer<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">11</span>
}
</pre></div>

<p>Though we're using the <em>same FSM for behavior</em>, the <em>state is tracked separately</em>. This enables you to keep a smaller memory footprint, especially in situations where you'd otherwise have lots of individual instances of the same FSM in play. More importantly, though, it allows you to take a more functional approach to FSM behavior and state should you prefer to do so. (As a side note, it also makes it much simpler to store a client's state and re-load it later and have the FSM pick up where it left off, etc.)</p>

<h4>
<a id="the-fsm-constructor" class="anchor" href="#the-fsm-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Fsm Constructor</h4>

<p>If you've used machina prior to v1.0, the <code>Fsm</code> constructor is what you're familiar with. It's functionally equivalent to the <code>BehavioralFsm</code> (in fact, it inherits from it), except that it can only deal with one client: <em>itself</em>. There's no need to pass a <code>client</code> argument to the API calls on an <code>Fsm</code> instance, since it only acts on itself. All of the metadata that was stamped on our <code>light1</code> and <code>light2</code> clients above (under the <code>__machina__</code> property) is at the instance level on an <code>Fsm</code> (as it has been historically for this constructor).</p>

<h3>
<a id="wait---whats-this-about-inheritance" class="anchor" href="#wait---whats-this-about-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wait - What's This About Inheritance?</h3>

<p>machina's FSM constructor functions are simple to extend. If you don't need an instance, but just want a modified constructor function to use later to create instances, you can do something like this:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> TrafficLightFsm <span class="pl-k">=</span> machina.Fsm.extend({ <span class="pl-c">/* your options */</span> });

<span class="pl-c">// later/elsewhere in your code:</span>
<span class="pl-k">var</span> trafficLight <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">TrafficLightFsm</span>();

<span class="pl-c">// you can also override any of the options:</span>
<span class="pl-k">var</span> anotherLight <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">TrafficLightFsm</span>({ initialState<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>go<span class="pl-pds">"</span></span> });</pre></div>

<p>The <code>extend</code> method works similar to other frameworks (like Backbone, for example). The primary difference is this: <em>the states object will be deep merged across the prototype chain</em> into an instance-level <code>states</code> property (so it doesn't mutate the prototype chain). This means you can add new states as well as add new (or override existing) handlers to existing states as you inherit from "parent" FSMs. This can be very useful, but – as with all things inheritance-related – use with caution!</p>

<h3>
<a id="and-you-mentioned-events" class="anchor" href="#and-you-mentioned-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>And You Mentioned Events?</h3>

<p>machina FSMs are event emitters, and subscribing to them is pretty easy:</p>

<div class="highlight highlight-javascript"><pre>
<span class="pl-c">// I'd like to know when the transition event occurs</span>
trafficLight.on(<span class="pl-s"><span class="pl-pds">"</span>transition<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">data</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>we just transitioned from <span class="pl-pds">"</span></span> <span class="pl-k">+</span> data.fromState <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> to <span class="pl-pds">"</span></span> <span class="pl-k">+</span> data.toState);
});

<span class="pl-c">// Or, maybe I want to know when ANY event occurs</span>
trafficLight.on(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">eventName</span>, <span class="pl-smi">data</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>this thing happened:<span class="pl-pds">"</span></span>, eventName);
});
</pre></div>

<p>Unsubscribing can be done a couple of ways:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c">//each listener gets a return value</span>
<span class="pl-k">var</span> sub <span class="pl-k">=</span> trafficLight.on(<span class="pl-s"><span class="pl-pds">"</span>transition<span class="pl-pds">"</span></span>, someCallback);
sub.off(); <span class="pl-c">// unsubscribes the handler</span>

<span class="pl-c">// OR, we can use the FSM's prototype method -</span>
<span class="pl-c">// remove this specific subscription:</span>
trafficLight.off(<span class="pl-s"><span class="pl-pds">"</span>transition<span class="pl-pds">"</span></span>, someCallback);
<span class="pl-c">// remove all transition subscribers</span>
trafficLight.off(<span class="pl-s"><span class="pl-pds">"</span>transition<span class="pl-pds">"</span></span>);
<span class="pl-c">// remove ALL subscribers, period:</span>
trafficLight.off();</pre></div>

<p>You can emit your own custom events in addition to the built-in events machina emits. To read more about these events, see the <a href="https://github.com/ifandelse/machina.js/wiki">wiki</a>.</p>

<h3>
<a id="things-suddenly-got-hierarchical" class="anchor" href="#things-suddenly-got-hierarchical" aria-hidden="true"><span class="octicon octicon-link"></span></a>Things Suddenly Got Hierarchical!</h3>

<p>One of the most exciting additions in v1.0: machina now supports hierarchical state machines. Remember our earlier example of the <code>vehicleSignal</code> FSM? Well, that's only <em>part</em> of a pedestrian crosswalk. Pedestrians need their own signal as well - typically a sign that signals "Walk" and "Do Not Walk". Let's peek at what an FSM for this might look like:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> pedestrianSignal <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">machina.Fsm</span>( {
    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>pedestrian-signal<span class="pl-pds">"</span></span>,
    initialState<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>uninitialized<span class="pl-pds">"</span></span>,
    <span class="pl-en">reset</span>: <span class="pl-k">function</span>() {
        <span class="pl-v">this</span>.transition( <span class="pl-s"><span class="pl-pds">"</span>walking<span class="pl-pds">"</span></span> );
    },
    states<span class="pl-k">:</span> {
        uninitialized<span class="pl-k">:</span> {
            <span class="pl-s"><span class="pl-pds">"</span><span class="pl-en">*</span><span class="pl-pds">"</span></span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.deferUntilTransition();
                <span class="pl-v">this</span>.transition( <span class="pl-s"><span class="pl-pds">"</span>walking<span class="pl-pds">"</span></span> );
            }
        },
        walking<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">30000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>pedestrians<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">WALK</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>flashing<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>( <span class="pl-v">this</span>.timer );
            }
        },
        flashing<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">5000</span> );
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>pedestrians<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">DO_NOT_WALK</span>, flashing<span class="pl-k">:</span> <span class="pl-c1">true</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>dontwalk<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>( <span class="pl-v">this</span>.timer );
            }
        },
        dontwalk<span class="pl-k">:</span> {
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.timer <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>() {
                    <span class="pl-v">this</span>.handle( <span class="pl-s"><span class="pl-pds">"</span>timeout<span class="pl-pds">"</span></span> );
                }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">1000</span> );
            },
            _reset<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>walking<span class="pl-pds">"</span></span>,
            <span class="pl-en">_onExit</span>: <span class="pl-k">function</span>() {
                <span class="pl-c1">clearTimeout</span>( <span class="pl-v">this</span>.timer );
            }
        }
    }
} )</pre></div>

<p>In many ways, our <code>pedestrianSignal</code> is similar to the <code>vehicleSignal</code> FSM:</p>

<ul>
<li>It starts in the <code>uninitialized</code> state, and the first input causes it to transition to <code>walking</code> before actually processing the input.</li>
<li>It can only be in one of four states: <code>uninitialized</code>, <code>walking</code>, <code>flashing</code> and <code>dontwalk</code>.</li>
<li>This FSM's input is primarily internally-executed, based on timers (<code>setTimeout</code> calls).</li>
</ul>

<p>Now - we <em>could</em> stand up an instance of <code>pedestrianSignal</code> and <code>vehicleSignal</code>, and subscribe them to each other's <code>transition</code> events. This would make them "siblings" - where <code>pedestrianSignal</code> could, for example, only transition to <code>walking</code> when <code>vehicleSignal</code> is in the <code>red</code> state, etc. While there are scenarios where this sort of "sibling" approach is useful, what we really have is a hierarchy. There are two higher level states that each FSM represents, a "vehicles-can-cross" state and a "pedestrians-can-cross" state. With machina v1.0, we can create an FSM to model these higher states, and attach our <code>pedestrianSignal</code> and <code>vehicleSignal</code> FSMs to their parent states:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> crosswalk <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">machina.Fsm</span>( {
    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>crosswalk<span class="pl-pds">"</span></span>,
    initialState<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>vehiclesEnabled<span class="pl-pds">"</span></span>,
    states<span class="pl-k">:</span> {
        vehiclesEnabled<span class="pl-k">:</span> {
            _child<span class="pl-k">:</span> vehicleSignal,
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>pedestrians<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">DO_NOT_WALK</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>pedestriansEnabled<span class="pl-pds">"</span></span>
        },
        pedestriansEnabled<span class="pl-k">:</span> {
            _child<span class="pl-k">:</span> pedestrianSignal,
            <span class="pl-en">_onEnter</span>: <span class="pl-k">function</span>() {
                <span class="pl-v">this</span>.emit( <span class="pl-s"><span class="pl-pds">"</span>vehicles<span class="pl-pds">"</span></span>, { status<span class="pl-k">:</span> <span class="pl-c1">RED</span> } );
            },
            timeout<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>vehiclesEnabled<span class="pl-pds">"</span></span>
        }
    }
} );</pre></div>

<p>Notice how each state has a <code>_child</code> property? This property can be used to assign an FSM instance to act as a child FSM for this parent state (or a factory function that produces an instance to be used, etc.). Here's how it works:</p>

<ul>
<li>When an FSM is handling input, it attempts to let the child FSM handle it first. If the child emits a <code>nohandler</code> event, the parent FSM will take over and attempt to handle it. For example - if a <code>pedestrianWaiting</code> input is fed to the above FSM while in the <code>vehiclesEnabled</code> state, it will be passed on to the <code>vehicleSignal</code> FSM to be handled there.</li>
<li>Events emitted from the child FSM are bubbled up to be emitted by the top level parent (except for the <code>nohandler</code> event).</li>
<li>If a child FSM handles input that it does not have a handler for, it will bubble the input up to the parent FSM to be handled there. Did you notice that both our <code>pedestrianSignal</code> and <code>vehicleSignal</code> FSMs queue up a <code>timeout</code> input in the <code>dontwalk</code> and <code>red</code> states, respectively? However, neither of those FSMs have an input handler for <code>timeout</code> in those states. When these FSMs become part of the hierarchy above, as children of the <code>crosswalk</code> FSM, the <code>timeout</code> input will bubble up to the parent FSM to be handled, where there <em>are</em> handlers for it.</li>
<li>When the parent FSM transitions to a new state, any child FSM from a previous state is ignored entirely (i.e. - events emitted, or input bubbled, will <em>not</em> be handled in the parent). If the parent FSM transitions back to that state, it will resume listening to the child FSM, etc.</li>
<li>As the parent state transitions into any of its states, it will tell the child FSM to handle a <code>_reset</code> input. This gives you a hook to move the child FSM to the correct state before handling any further input. For example, you'll notice our <code>pedestrianSignal</code> FSM has a <code>_reset</code> input handler in the <code>dontwalk</code> state, which transitions the FSM to the <code>walking</code> state.</li>
</ul>

<blockquote>
<p>Caveats: This feature is very new to machina, so expect it to evolve a bit. I plan to fine-tune how events bubble in a hierarchy a bit more, and potentially give the parent FSM the ability to express the state down the hierachy (e.g. <code>vehiclesEnabled.green</code> or <code>pedestriansEnabled.dontwalk</code>).</p>
</blockquote>

<h3>
<a id="the-top-level-machina-object" class="anchor" href="#the-top-level-machina-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Top Level machina object</h3>

<p>The top level <code>machina</code> object has the following members:</p>

<ul>
<li>
<code>Fsm</code> - the constructor function used to create FSMs.</li>
<li>
<code>BehavioralFsm</code> – the constructor function used to create BehavioralFSM instances.</li>
<li>
<code>utils</code> - contains helper functions that can be overridden to change default behavior(s) in machina:

<ul>
<li>
<code>makeFsmNamespace</code> - function that provides a default "channel" or "exchange" for an FSM instance.  (e.g. - fsm.0, fsm.1, etc.)</li>
</ul>
</li>
<li>
<code>on</code> - method used to subscribe a callback to top-level machina events (currently the only event published at this level is <code>newFsm</code>)</li>
<li>
<code>off</code> - method used to unsubscribe a callback to top-level machina events.</li>
<li>
<code>emit</code> - top-level method used to emit events.</li>
<li>
<code>eventListeners</code> - an object literal containing the susbcribers to any top-level events.</li>
</ul>

<h2>
<a id="build-tests--examples" class="anchor" href="#build-tests--examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Build, Tests &amp; Examples</h2>

<p>machina.js uses <a href="http://gulpjs.com/">gulp.js</a> to build.</p>

<ul>
<li>Install node.js (and consider using <a href="https://github.com/creationix/nvm">nvm</a> to manage your node versions)</li>
<li>run <code>npm install</code> &amp; <code>bower install</code> to install all dependencies</li>
<li>To build, run <code>npm run build</code> - then check the lib folder for the output</li>
<li>To run the examples:

<ul>
<li><code>npm start</code></li>
<li>navigate in your browser to <a href="http://localhost:3080/">http://localhost:3080/</a>
</li>
</ul>
</li>
<li>To run tests &amp; examples:

<ul>
<li>To run node-based tests: <code>npm run test</code>
</li>
<li>To run istanbul (code test coverage): <code>npm run coverage</code>
</li>
<li>To see a browser-based istanbul report: <code>npm run show-coverage</code>
</li>
</ul>
</li>
</ul>

<h2>
<a id="release-notes" class="anchor" href="#release-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Notes</h2>

<p>Go <a href="https://github.com/ifandelse/machina.js/blob/master/changelog.md">here</a> to see the changelog.</p>

<h2>
<a id="have-more-questions" class="anchor" href="#have-more-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Have More Questions?</h2>

<p>Read the <a href="https://github.com/ifandelse/machina.js/wiki">wiki</a> and the source – you might find your answer and more! Check out the <a href="https://github.com/ifandelse/machina.js/issues/4">issue</a> opened by <a href="https://github.com/burin" class="user-mention">@burin</a> - a <em>great</em> example of how to use github issues to ask questions, provide sample code, etc. I only ask that if you open an issue, that it be <em>focused on a specific problem or bug</em> (not wide-open ambiguity, please).</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-30321396-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
